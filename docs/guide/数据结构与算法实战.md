---
title: 数据结构与算法实战
autoGroup-1: 基础
autoSort: 16
---
## 数据结构与算法实战

### 程序的本质

程序是有一系列的机器指令构成。

程序=数据结构+算法

数据结构与算法是相辅相成的。

#### 数据结构：

数据结构是计算机存储，组织数据的方式。**数据结构是指的相互之间存在一种或多种特定关系的数据元素的集合**。通常情况下精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

对**处理的问题如何表示**，即问题的**数学模型**是什么

简言之：是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。

<font color="red">“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</font>

##### 基本术语：

###### 数据(Data)：

​     **在计算机科学中，是指所有** 能输入到计算机中并被计算机程序处理的符号的总称（**集合**）  它是对客观事物的符号表示（描述），是计算机处理的信息的特定的符号表示形式（信息的载体）。

​     **数据结构中所讨论数据的范畴很广泛，如：字符、声音、图形、图像等多媒体信息。随着计算机的发展，数据的范畴不断扩大**

比如：

```
struct student{
	long num;
	char name[20];
	char sex;
	char addr[30];
}
struct student s1,s2[6];
```

###### 数据元素(Data Element)

**是数据 ( 集合 ) 中的一个 “ 个体 ” ，在计算机中通常作为一个整体进行考虑和处理。 是数据结构中讨论的 “ 基本单位 ” ， 但不是 最小 单位，它常常有若干 数据项 （ 是对数据元素 不同 属性 的描述 ， 具有 独立的意义 ） 组成 。**

比如：**在学生信息管理系统中， 一条学生纪录 就是 一个数据元素 （学号、姓名、性别等数据项组成）**

| 学号  | 姓名 | 班级    | 地址 |
| ----- | ---- | ------- | ---- |
| s0001 | scd  | class01 | addr |

**数据元素有两类。**

- 一类是不可分割的具有 “原子”型数据元素。如：整数 字符。
- 另一类：由多个款项构成的数据元素（结构型） 其中每个款项被称为一个 “数据项” 是对数据元素某种属性的描述具有独立意义。



###### 关键字

**指能识别一个或多个数据元素的数据项。若能起 唯一 识别作用，则称之为**
**“ 主 ”** **关键字 ，否则称之为“ 次 ”关键字** 比如学号为主关键字。其余为次关键字。

###### 数据对象(Data Object):

是性质相同的数据元素的集合，是数据的一个子集。比如 整数，实数，都是数据的一个子集



[![DiyNp4.png](https://s3.ax1x.com/2020/11/15/DiyNp4.png)](https://imgchr.com/i/DiyNp4)

##### **数据的逻辑结构：**

<font color="red">数据的逻辑结构反应的是数据元素之间的逻辑关系，是指数据元素之间的前后间的关系，而与元素所存储的位置无关</font>。逻辑结构包含：

- 集合：数据结构中的元素之间除了“同一集合”的相互关系外，别无其他关系。
- 线性结构：数据结构中的元素存在一对一的相互关系。
- 树形结构：数据结构中的元素存在一对多党的相互关系。
- 图形结构：数据结构中的元素存在多对多的相互关系。

一般按照逻辑结构分类数据结构可分为：

线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 线性结构是非空集合

- 线性结构有且仅有一个开始结点和一个终端结点。

- 线性结构所有的结点都最多有一个直接前趋结点和一个后继结点。

  包含：线性表，栈，队列，串

非线性结构：线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：

- 非线性结构是非空集。

- 非线性结构的一个结点可能有多个直接结点和多个后继结点。

  包含：数组，广义表，树结构和图结构

###### 逻辑结构的表示

**数据结构的形式定义为一个二元组：**

​            **Data-Structure=(  D  ，  S)**

**其中：  D  是数据元素的  有限  集，**

​      **S  是  D  上  关系的有限  集。**

> **例  复数的数据结构定义如下  :** **(  复数  x=C1 + C2** **i** **)**
>
> ​           **Complex=(  C  ，  R  )**
>
> **其中：**
>
>   **C  是含两个实数的集合  ﹛  C1  ，  C2  ﹜  ，分别表示复数的  实部  和  虚部  。**
>
>   **R  ={P}  ，  P  是定义在集合上的一种序偶关系：**
>
> ​         **{<C1  ，  C2>}  。  有序对  <>  ,  区别  （）**
>
> **有序对  <  x,y  >  －  y  是  x  的后继，**
> **x  是  y  的前驱：“  相邻  ”**
>
> **一个  <  x,y  >  的  有序对  是构成关系的  基本单位**





##### **数据的物理结构：**

指数据的[逻辑结构]在计算机存储空间的存放形式。

数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。

数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）。

关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系。

##### **数据的存储结构：**

数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等

- **顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；**
- **非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系**

[![DixLu9.png](https://s3.ax1x.com/2020/11/15/DixLu9.png)](https://imgchr.com/i/DixLu9)
[![DixbjJ.png](https://s3.ax1x.com/2020/11/15/DixbjJ.png)](https://imgchr.com/i/DixbjJ)

#### 算法：

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰[指令]，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的[输入]，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用[空间复杂度]与[时间复杂度]来衡量。

算法中的指令描述的是一个[计算]，当其[运行]时能从一个初始状态和（可能为空的）初始输入开始，经过一系列**有限**而清晰定义的状态，最终产生**输出**并**停止**于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。

**特征：**

- 有穷性（Finiteness：算法的有穷性是指算法必须能在执行有限个步骤之后终止；
- 确切性(Definiteness)：算法的每一步骤必须有确切的定义；
- 输入项(Input)：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
- 输出项(Output)：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
- 可行性(Effectiveness)：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算[步骤](https://baike.baidu.com/item/步骤/7066340)都可以在有限时间内完成（也称之为有效性）

**算法的评定：**

- 时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。T(n)=Ο(f(n))
- 因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作[渐进时间复杂度](https://baike.baidu.com/item/渐进时间复杂度)（Asymptotic Time Complexity）。
- 空间复杂度：算法的[空间复杂度](https://baike.baidu.com/item/空间复杂度/9664257)是指算法需要消耗的内存空间。其计算和表示方法与时间[复杂度](https://baike.baidu.com/item/复杂度)类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。
- 正确性：算法的正确性是评价一个算法优劣的最重要的标准。
- 可读性：算法的可读性是指一个算法可供人们阅读的容易程度。 [1] 
- 健壮性：健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为**容错性**

### 函数与递归

为何自己写不出递归呢？

需要 需要确定信念。确定递归的结束条件和递归条件

```java
 /**
     * 递归函数求阶乘
     *
     * @param n
     * @return
     */
    private static int fact(int n) {
        // 递归必须确定结束条件
        if (n < 2) {
            return 1;
        }
        return n * fact(n - 1);
    }

    /**
     * 汉诺塔
     *
     * @param n   盘子数
     * @param src 元盘子
     * @param mid 中间盘子
     * @param tar 目标盘子
     */
    private static void hanoi(int n, int src, int mid, int tar) {
        // 确定结束条件
        if (n == 1) {
            System.out.println(src + "-->" + tar);
        } else {
            hanoi(n - 1, src, tar, mid); // 把n-1个盘子从元盘子借助目标柱子放到中间柱子
            hanoi(1, src, mid, tar); // 把一个盘子从原主借助中间住放到目标住
            hanoi(n - 1, mid, src, tar); // 把n-1个盘子从中间住借助源住放到目标住
        }

    }
```

### 数组与字符串

#### 数组：

##### 数组的定义：

就是线性表的实现。

**c语言**

定义： `int array[N] 或者 int *array = malloc();`

数组的名不是指针。

```c
#include <stdio.h>
#include <stdio.h>
// 这个地方其实是传入的数组的地址 *array，和大小
int func(int *array,int size){
    // array[0] 其实就是指针 array求值得出首地址
	return array[0]; // 等价于 *(array+0);
}
int main(int argc,const char * argv[]){
    // array是一个数组
	int array[100] = {11,22,33,44};
    // 指针的形式
	int *p = malloc(100 * sizeof(int));
    // 在这里是获取到了数组的指针
    printf("%d\n",*(array+1));
    
    // 传入的其实是数组首地址的指针
	printf("%d\n",func(array,100));
	return 0;
}
```

**c++:**

数组定义：`int array[N] 或 int * array = new int[N];`

**java**

数组定义：`int array[] = new int[N];`

```java
public class main{
	public static void main(String[] args){
		int [] array = new int[10];
		array[1]=222;
		array[2]=333;
		System.out.println(array.length);
        ArrayList<Integer> list = new ArrayList<>();
        list.add(123);
        list.add(22);
        System.out.println(list);
	}
}
```

**python**

数组定义： `array = [];`

##### 数组元素的查找：

###### c语言实现：

```c
#include <stdio.h>

/**
** 根据值找到下标
*/
int findX(int * array,int size,int x){
	int flag=0;
	int index=-1;
	for(int i=0;i<size;i++){
		if(array[i]==x){
			flag =1;
			index = i;
		}
	}
	return index;
}
/**
** 根据下标找到值,并把原来的地址给返回过来，并返回状态。
*/
int findElement(int * array,int size, int k, int *px){
    if(k>=size || k<0) return 0;
    else{
        *px=array[k];
        return 1;
    }
}
/**
* 查找最大的。
*/
int findMax(int * array, int size){
    // 是将数组中的一个元素初始为max;
    int max =array[0];
    for(int i=1;i<size;i++){
        if(max<array[i]) max = array[i];
    }
    return max;
}
int main(int argc,const char * argv[]){
	int array[10] = {111,112,33,44,55};
	int x;
	x=12;
	int k;
	k= findX(array,10,x);
	printf("%d\n",k);
    int m,flag;
    // 传入的是数组引用，长度，和下标，和地址
    flag= findElement(array,10,3,&m);
    printf("%d,%d\n",flag,m);
	// 查找最大值
    int max ;
    max = findMax(array,10);
    printf("%d\n",max);
	return 0;
}
```

##### **求两个100位的十进制的和。**

###### C语言实现

```c
int main(int argc, const char * argv[]){
    // 
    // 思路 用数组 ，数组的底位存0号元素(如果0号元素存在高位，则是不可以进位的)
    int a[11] = {0,9,8,7,6,5,4,3,2,1};
    int b[11] = {1,2,3,4,5,6,7,8,9,9};
    int sum[11] = {0};
    int carry=0;//进位操作
    // i< 11是为了计算最后一个
    for(int i=0;i<11;i++){
        int s;
        s=a[i]+b[i]+carry;
        carry = s/10;
        sum[i] = s%10;
    }
    for(int i=10;i>=0;i--){
        printf("%d",sum[i]);
    }
    putchar('\n');
	return 0;
}
```

###### java 实现：

```java
public static void main(String[] args){
	BigInteger a= new BigInteger("12345678");
	BigInteger b= new BigInteger("12345678");
	BigInteger c= a.add(b);
	System.out.println(c);
}
```

#### 二维数组

二维数组的实质：数组的数组。数组中的每一个元素仍然是个数组。

逻辑上可看做二维，其实并不是二维的

**c语言**

`int array [][]  与 int **array`

`int array[3][4];和int **pa 的中的array和pa类型是相同的，但是 pa== array的写法是错误的`

`int array [ ][ ]` 与`int * *`

array是数组的数组。

int *p ===> 是p 指向一个整形变量。

p[2] <==> *(p+2)  就是 p指向的整形变量再+2的位置就是 p[2]

int * * p  因为*靠p元素最近，所以p是一个指针。所以 * * p是指的是指针的指针。`p[1][1]`与 `p[0][1]`的位置截然不同，并不是相差一个 

`int * *p= array是错误的`

```c
#include <stdio.h>

int main(void) { 
	printf("test");
	int array[3][5]; // 是由int[5]
	
	//int *p[5];
	//p =array; // 这样是错误的。
	
	
	int (*p)[5];
	p = array; // 数组名赋值与指针。 那也就是 array是 一个指针。
	
	int a[10];
	int *pa =a // s数组的名求值可获取数组元素的受地址。所以 *pa就是一个指针。
	
	return 0;
}
```

**数组传参：**

```c
#include <stdio.h>
vaid func(int (*)[5] , int ){
    // int (*)[5] 就是一个指向[5]的指针
}
void func(int array[][5] ,int k){
    // int array[][5]==>int (*p) [5];
    
}

int main(void) { 
	printf("test");
	int array[3][5]; // 是由int[5]
	
	//int *p[5];
	//p =array; // 这样是错误的。
	
	
	int (*p)[5];
	p = array; // 数组名赋值与指针。 那也就是 array是 一个指针。
	
	// 这传递的是指针
	func(array, 3);
	
	int a[10];
	int *pa =a // s数组的名求值可获取数组元素的受地址。所以 *pa就是一个指针。
	
	return 0;
}
```

**`java`**

```java
public void test(){
    // 这是个3行的但是列未定义。
	int[][] array= new int[3][];
	array[0] = new int[5]; // 第0行有5列 ，创建有5个整形变量的数组
	arry[1] = new int[4];
	array[2]= new int[3];
}
```



##### 大炮打蚊子案例：

```c
/**
 * 蚊子分布在一个M×N格的二维平面上，每只蚊子占据一格。向该平面的任意位置发射炮弹，炮弹的杀伤范围如下示意：

 O
OXO
 O
其中，X为炮弹落点中心，O为紧靠中心的四个有杀伤力的格子范围。若蚊子被炮弹命中（位于X格），一击毙命，若仅被杀伤（位于O格），则损失一半的生命力。也就是说，一次命中或者两次杀伤均可消灭蚊子。现在给出蚊子的分布情况以及连续k发炮弹的落点，给出每炮消灭的蚊子数。

输入格式:
第一行为两个不超过20的正整数M和N，中间空一格，表示二维平面有M行、N列。

接下来M行，每行有N个0或者#字符，其中#表示所在格子有蚊子。

接下来一行，包含一个不超过400的正整数k，表示发射炮弹的数量。

最后k行，每行包括一发炮弹的整数坐标x和y（0≤x<M，0≤y<N），之间用一个空格间隔。

输出格式:
对应输入的k发炮弹，输出共有k行，第i行即第i发炮弹消灭的蚊子数。

输入样例:
5 6
00#00#
000###
00#000
000000
00#000
2
1 2
1 4
输出样例:
0
2
 * */
#include <stdio.h>

int board[20][20];
int M,N;
// 函数处理逻辑 当前坐标 和 杀上力
int bang(int x, int y, int kill){
    if((x>=0 && x<M) && (y>=0 && y<N) && board[x][y]>0){
        board[x][y] -=kill;
        if(board[x][y]<=0){
            // 蚊子死了
            return 1;
        }else{
            return 0;
        }
    }else{
        return 0;
    }
    return 1;
}
int main(int argc, const char * argv[]){
   scanf("%d%d",&M,&N);
   getchar();// 去除换行符
   for(int i=0;i<M;i++){
       for(int j=0;j<N;j++){
           // 给数组赋值：令蚊子的生命力为2;因为如果为1时炮弹没有击中，而是在
           // 炮弹范围内所以让其生命力为2更好计算。
           board[i][j] = getchar() == '0' ? 0:2;
       }
       // 再次读取换行符
       getchar();
   }
   int k;
   scanf("%d",&k);
   
   for(int i=0;i<k;i++){
    // 用来定义大炮打的一泡的落点
       int x,y;
       scanf("%d%d",&x,&y);
       int count=0;
       count += bang(x,y,2);
       count += bang(x-1,y,1);
       count += bang(x,y-1,1);
       count += bang(x,y+1,1);
       printf("%d\n",count);
           
   }
   
	return 0;
}
```

#### 字符串

字符串就是一串字符。

##### 字符串的定义：

**c语言**：“abcdefeg” 或 字符数组

```c
#include <stdio.h>

int main(void) { 
	// c 语言运行时内存有四个部分: 栈，堆，常量区，代码块
	char *str ="hello world";
	printf("%s\n",str);
	printf("%p\n",str);
	char *str2 ="hello world";
    printf("%s\n",str2);
	printf("%p\n",str2);
	
	// 这的是s3放到了堆栈里了
	char s3[] = "hello";
	printf("%s\n",s3);
	printf("%p\n",s3);
	
	// s4数组是将常量池中的拿过来
	char s4[] = "hello word";
	printf("%s\n",s4);
	printf("%p\n",s4);
	printf("%d\n",sizeof(s3));
	return 0;
}
// 输出：
hello world
0x402004
hello world
0x402004
hello
0x7fffc8a4589a
hello word
0x7fffc8a4588f
6
可以看到 *str 与*str 两个字符的指针指向的位置相同。
```

**c++**

```c++
#include <iostream>
using namespace std;

int main() {
    string name;
    
	cout  << name <<"\n"; // 什么都没有是空字符串
	
	string name2="llk";
	
	cout  << name2 <<"\n"; 

	return 0;
}
```

**java**

```java
public void name(){
	String name ="张三";
	System.out.println(name);
	// java一般都是new出来的而这个却可以直接复值；
	// String name = "zhang" 这个其实就是在常量池中创建了一个对象，然后name引用指向常量池； 等价于 char data[] = {'z','h','a','n',y};
	String namestr= new String(data);
	// String name = new String("zhang");
	// 这个是在堆栈中创建一个新的对象将“zhang”放到静态区
}
String str="hello";//直接赋值的方式，先在栈中创建一个对String类的对象的引用变量str,然后查找栈中有没有存放“hello”，如果没有就将“hello”存放在栈，并令star指向“hello”,如果已经有“hello”直接令str指向“hello”

通过构造方法创建字符串对象是在堆内存
String str=new String("hello");//实例化的方式

1）直接赋值（String str = "hello"）：只开辟一块堆内存空间，并且会自动入池(到常量池中)，不会产生垃圾。

2）构造方法（String str=  new String("hello");）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池(到常量池中)，需要通过public  String intern();方法进行手工入池(到常量池中)。new的每次都会创建对象，他只会存在堆中，每次调用一次就会创建一个新的对象。 将“hello”放到静态区

在开发的过程中不会采用构造方法进行字符串的实例化。
```

##### 正则表达式与串的匹配

正则表达式是用于对字符串的匹配。

##### 自动机

- 非确定型有限状态自动机(NFA):
- 确定型有限状态自动机(DFA):

```java
// C++;

#include <iostream>
using namespace std;
#include <regex>
int main() {
    string str ="abcd";
    regex r("[a-z]+"); // 匹配一个或多个字母
    string email = "abc123@123.xm";
    regex r1("[a-z0-9]+@[a-z0-9]+\\.[a-z0-9]+");
    bool x=regex_match(str,r);
    cout << x <<endl;

    cout << regex_match(email,r1) << endl;
	return 0;
}
// java 使用类 pattern类
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数

public static void main(String args[]){
      String content = "I am noob " +
        "from runoob.com.";
 
      String pattern = ".*runoob.*";
 
      boolean isMatch = Pattern.matches(pattern, content);
      System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);
 }
 
// python
import re;
re(r"正则表达式","匹配的字符")
```

### 线性结构

#### 什么是线性结构：

**线性结构的定义**：

**若结构是非空有限集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继**  可表示为如下图所示。

**线性结构中数据元素之间的关系就是这种“直接前驱”或“直接后继”的相邻关系，可以用一个有序对表示,如：a2与a3的关系：<a2,a3>**

[![Di52Is.png](https://s3.ax1x.com/2020/11/15/Di52Is.png)](https://imgchr.com/i/Di52Is)

**线性结构的特点：**

**①** **只有一个首结点和尾结点；**

**② 除首尾结点外，其他结点只有一个直接前驱和一个直接后继。**

**线性结构包括线性表、堆栈、队列、字符串、数组等等，其中，最典型、最常用的是线性表**

#### 线性表：

是一种最简单的线性结构。简单地说，**是一个有序集合：用数据元素的有限序列表示**

是由n个数据元素(结点) 常常将非空的线性表记为L = (a1,a2,a3,a4,a5... an); 

其中

-  L：是线性表的表名
- n表示数据元素的个数，当n=0时成为空表。表中的数据元素a时一个抽象的符号，成为i在ai在线性表中的位序。

[![DizsV1.png](https://s3.ax1x.com/2020/11/15/DizsV1.png)](https://imgchr.com/i/DizsV1)



##### **线性表四个基本特征：**

**1.集合中必存在唯一的一个“第一元素”；**

**2.集合中必存在唯一的一个“最后元素”；**

**3.除最后元素之外，其它数据元素均有唯一的“直接后继”；**

**4.除第一元素之外，其它数据元素均有唯一的“直接前驱”；**

**线性表的顺序表示又称为**：**顺序存储结构或顺序映像**

##### 线性表的存储

用一组地址连续的存储单元依次存放线性表中的数据元素。**借助元素在存储器中的**相对位置来表示  **数据元素间的逻辑关系**

#### 顺序表

##### 定义：

**顺序表**是线性表的顺序存储表示的简称，它指的是，“用一组**地址连续**的存储单元**依次存放**线性表中的数据元素”，即以“**存储位置相邻**”表示“位序相继的两个数据元素之间的前驱和后继的关系

>(有序对<ai-1，ai)”，并以表中第一个元素的存储位置作为线性表的起始地址，称作**线性表的基地址**

**顺序存储定义：** 把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构

**顺序存储方法：**用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现

**顺序表的类型定义：**

```c
#define  MAXSIZE 100     //最大长度
typedef  struct {
  ElemType  *elem;     //指向数据元素的基地址
  int  length;          //线性表的当前长度                                                      
 }SqList；
```

**顺序表存储结构定义：**

```c
#define MAXSIZE 10000	//图书表可能达到的最大长度 
typedef struct			//图书信息定义
{ 
   char no[20];			//图书ISBN
   char name[50];		//图书名字
   float price; 			//图书价格
}Book; 
typedef struct
{ 
   Book *elem;	//存储空间的基地址 
   int length;		//图书表中当前图书个数 
}SqList;		//图书表的顺序存储结构类型为SqList

```

##### **顺序表的特点：**

**（1）利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致**

**（ 2 ）在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为， 访问每个元素所花时间相等**　

##### **顺序表的优缺点:**

**优 点：**

1. **存储密度大 （结点本身所占存储量 / 结点结构所占存储量）**
2. **可以 随机存取 表中任一元素**

**缺点：**

1. **在插入、删除某一元素时，需要移动大量元素**
2. **浪费存储空间**
3. **属于静态存储形式，数据元素的个数不能自由扩充**

**c语言动态分配函数：**

**malloc(m)：开辟m字节长度的地址空间，并返回这段空间的首地址**

**sizeof(x)：计算变量x的长度**

**free(p)：释放指针p所指变量的存储空间，即彻底删除一个变量**

##### 实现线性表

###### C语言

[![DiHTUg.png](https://s3.ax1x.com/2020/11/15/DiHTUg.png)](https://imgchr.com/i/DiHTUg)

代码：

```c
#include <stdio.h>

#define MAX 10

// 使用结构体
struct Slist{
    int data[MAX];
    int length;
};
// 初始化
void init(struct Slist* p){
    p->length =0;
}
// 打印
void printList(const struct Slist* p){
    for(int i=0;i<p->length;i++){
        printf("%d",p->data[i]);
    }
    putchar('\n');
    
}
// 插入
int insert(struct Slist* p, int k, int x){
    // 判断插入的位置
    if(k<0 || k> p->length || p->length==MAX-1) return 0; // 表示失败
    for(int i=p->length-1;i>=k;i++){
        // 元素向后挪一位
        p->data[i+1] = p->data[i];
    }
    p->data[k] = x;
    p->length++;
    return 1;
    
}

// 删除
int delete1(struct Slist* p, int k, int *px){
    if(k<0 || k >= p->length) return 0;
    else {
        *px = p->data[k];
        for(int i= k+1; i<p->length;i++){
            p->data[i-1] = p->data[i];
        }
        p->length--;
        return 1;
    }
}
int main(void) { 
    struct Slist a;
    init(&a);
    // 插入 在0号元素插入x
    int k=0,x=11;
    insert(&a,k, x);
    
    // 删除并将返回删除的值的地址。
    int addr;
    delete1(&a, 1,&addr);
    // 这里传入a的话就会copy一份数组了，所以这里使用地址进行传入
    printList(&a);
	return 0;
}
```

###### c++

```c++
#include <iostream>
#include <list>
#include <vector>
#include <stack>
using namespace std;
int main(int argc ,const char * argv[]) {
   vector<int> v;
   v.push_back(11);
   v.push_back(12);
   v.push_back(13);
   // 使用迭代器
   vector<int> ::iterator it;
   for(it=v.begin(); it!=v.end();it++){
       cout<< *it << ",";
   }
   cout << endl;
    // 插入
   v.insert(v.begin(),666); // 在 0 号位置进插入
   v.insert(v.begin()+2, 333); // 在 2号位置进行插入
    // 删除
   v.erase(v.begin()+1); // 
   for(int i:v){
       cout << i << ",";
   }
    
   cout << endl;
	return 0;
}
```

###### **java**

```java
public void testArrayList(){
    ArrayList<Integer> list = new ArrayList<>();
   	list.add(123);
    list.add(234);
    // 在1号位置插入
    list.add(1,666);
    // 移除某个下标的。返回删除的元素
    int k=list.remove(2);
    
}
// 实现自己的顺序表
package com.java1995;

public class ArrayList {
	//定义Object[]数组；
	private Object[] objs;
	
	public 	ArrayList(){
		//初始容量
		objs=new Object[10];
	}
	public ArrayList(int size){
		objs=new Object[size];
	}
	//增加的方法
	public boolean add(Object obj){
		int index=-1;
		for(int i=0;i<objs.length;i++){
			if(objs[i]==null){//未放数据；
				index=i;
				break;
			}
		}
		if(index==-1){//要扩容；
			int oldlen=objs.length;
			//创建新的数组；
			Object[] objs2=new Object[objs.length*2];
//			老数组的数据复制到新的数组中；
			System.arraycopy(obj, 0, objs2, 0, objs.length);
			objs=objs2;
			objs[oldlen]=obj;
		}else{
			objs[index]=obj;
		}
		return true;
	}
	//删除的方法；
	public Object remove(int index){
		Object obj=objs[index];
		objs[index]=null;
		return obj;
	}
	//修改的方法；
	public Object set(int index,Object newobj){
		Object oldobj=objs[index];
		objs[index]=newobj;
		return oldobj;
		
	}
	//查找的方法；
	public Object get(int index){
		return objs[index];
	}
	@Override
	public String toString() {
		StringBuffer sb=new StringBuffer();
		//sb.append("[");
		for(Object obj: objs){
			if(obj==null)continue;
			sb.append(obj+" ");
		}
		//sb.append("]");
		return sb.toString();
	}
	
}

```

###### **Python**

```python
a=list();
a.append(11);
a.append(222);
# 插入
a.insert(3,33);
# 删除 用栈的方式弹出
a.pop(1);
```

#### 链表：

链表：n个结点由指针链组成一个链表，它是线性表的链式存储映像。称为线性表的链式存储结构。

链表的结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相等。链表对空间上有一定的要求，因为他的存储很可能分布在不同的位置。

链式存储结构：

[![D823Dg.png](https://s3.ax1x.com/2020/11/22/D823Dg.png)](https://imgchr.com/i/D823Dg)

链表各个**结点**由两个域组成，**数据域与指针域**  

- 数据域： 存放元素数值数据

- 指针域：存放直接后继结点的存储位置。

  ​	

[![DX5lTA.png](https://s3.ax1x.com/2020/12/06/DX5lTA.png)](https://imgchr.com/i/DX5lTA)

**头指针** 是指向链表中第一个结点的指针

**首元结点** 是指链表中存储第一个数据元素a1的结点

**头结点**  是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息

[![DX5rYq.png](https://s3.ax1x.com/2020/12/06/DX5rYq.png)](https://imgchr.com/i/DX5rYq)

   **有头结点时，**当头结点的指针域为空时表示空表

**设置头节点的好处**

**⒈** **便于首元结点的处理**

**首元结点的地址保存在头结点的指针域中****

**⒉**便于**空表和非空表**的统一处理

**无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了**

**头结点的**数据域可以为空，也可存放线性表**长度**等附加信息，但此结点不能计入链表长度值。



##### 链表分类：

单链表：结点只有一个指针域的链表

双链表：结点有两个指针域的链表

循环链表：首尾相接的链表称为循环链表
[![D8I1Wd.png](https://s3.ax1x.com/2020/11/22/D8I1Wd.png)](https://imgchr.com/i/D8I1Wd)

##### 链表的特点：

- **结点在存储器中的位置是 任意 的，即 逻辑上相邻的数据元素在物理上不一定相邻**
- **访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等**

##### 链表的优缺点：

**优点**

- ​	–**数据元素的个数可以自由扩充**
- ​	–**插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高**

**缺点**

​	•      **存储密度小**

​	•      **存取效率不高，必须采用 顺序存取 ，即存取数据元素时，只能按链表的顺序进行访问 （顺藤摸瓜）**

#### 单链表：

#####  定义

[![DG9OMV.png](https://s3.ax1x.com/2020/11/22/DG9OMV.png)](https://imgchr.com/i/DG9OMV)

**单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名**

**若头指针名是**L**，则把链表称为表**L 

##### 链表的操作

**求表长**：数结点，指针p依次指向各个结点，从第一个结点一直数到最后一个结点。

```
L->next === 就是看L的next是否有元素，
p=L->next; // p指向第一个结点
i=0;
while(p){i++;p=p->next}
这的p到最后一个结点后p==null了

int  ListLength_L(LinkList L){
//返回L中数据元素个数
    LinkList p;
    p=L->next;  //p指向第一个结点
     i=0;             
     while(p){//遍历单链表,统计结点数
           i++;
           p=p->next;    } 
    return i;                             
 }

```

**取值：** 链表的查找要从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止，因此链表不是随机存取结构。

**从第 1 个结点（ L->next ）顺链扫描，用指针 p 指向当前扫描到的结点， p 初值 p** **=** **L->next 。**

**j 做计数器，累计当前扫描过的结点数， j 初值为 1 。**

**当 p 指向扫描到的下一结点时，计数器 j 加 1 。**

**当 j = i  时 p  所指的结点就是要找的第  i  个结点**

```c
//获取线性表L中的某个数据元素的内容
Status GetElem_L(LinkList L,int i,ElemType &e){ 
    p=L->next;j=1; //初始化
     while(p&&j<i){	//向后扫描，直到p指向第i个元素或p为空 
       p=p->next; ++j; 
     } 
     if(!p || j>i)return ERROR; //第i个元素不存在 
     e=p->data; //取第i个元素 
     return OK; 
}//GetElem_L 

```

**查找**:根据指定数据获取数据所在的位置。

**从第一个结点起，依次和  e  相比较。**

**如果找到一个其值与  e  相等的数据元素，则返回其在链表中的  “  位置  ”或地址  ；**

**如果查遍整个链表都没有找到其值和 e相等的元素，否则返回0或 “NULL”**

```c
//在线性表L中查找值为e的数据元素
LNode *LocateELem_L (LinkList L，Elemtype e) {
 //返回L中值为e的数据元素的地址，查找失败返回NULL
  p=L->next;
  while(p &&p->data!=e)  
        p=p->next;                		
  return p; 	
} 

//在线性表L中查找值为e的数据元素
int LocateELem_L (LinkList L，Elemtype e) {
 //返回L中值为e的数据元素的位置序号，查找失败返回0 
  p=L->next; j=1;
  while(p &&p->data!=e)  
        {p=p->next;  j++;}          		
  if(p) return j; 
  else return 0;
} 

```

**插入**

•**将值为  x  的新结点插入到表的第  i  个结点的位置上，即插入到  a  i-1  与  a  i  之间**

[![DGCqFH.png](https://s3.ax1x.com/2020/11/22/DGCqFH.png)](https://imgchr.com/i/DGCqFH)

**s->next=p->next;      p->next=s**

**（ 1  ）找到  a  i-1  存储位置  p**

**（  2  ）生成一个新结点  *s**

**（  3  ）将新结点 *s  的数据域置为  x**

**（  4  ）新结点 *s  的指针域指向结点  a  i**

**（  5  ）令结点  *p  的指针域指向新结点 *s**

```c
Status ListInsert_L(LinkList &L,int i,ElemType e){ 
     p=L;j=0; 
      while(p&&j<i−1){p=p->next;++j;}	//寻找第i−1个结点 
      if(!p||j>i−1)return ERROR;	//i大于表长 + 1或者小于1  
      s=new LNode;			//生成新结点s 
      s->data=e;      		           //将结点s的数据域置为e 
      s->next=p->next;	   	          //将结点s插入L中 
      p->next=s; 
      return OK; 
}//
```

**删除：**

[![DGP8pR.png](https://s3.ax1x.com/2020/11/22/DGP8pR.png)](https://imgchr.com/i/DGP8pR)

**（  1  ）找到  a  i-1  存储位置  p**

**（  2  ）保存要删除的结点的值**

**（  3  ）令  p-  ＞  next  指向  a  i  的直接后继结点**

**（  4  ）释放结点  a  i  的空间**

```c
//将线性表L中第i个数据元素删除
 Status ListDelete_L(LinkList &L,int i,ElemType &e){
    p=L;j=0; 
    while(p->next &&j<i-1){//寻找第i个结点，并令p指向其前驱 
        p=p->next; ++j; 
    } 
    if(!(p->next)||j>i-1) return ERROR; //删除位置不合理 
    q=p->next; //临时保存被删结点的地址以备释放 
    p->next=q->next; 	//改变删除结点前驱结点的指针域 
    e=q->data; 	//保存删除结点的数据域 
    delete q; 	//释放删除结点的空间 
 return OK; 
}
```

##### 链表操作实现：

###### C语言

```c
#include <stdio.h>

#include<malloc.h>

// 两种形式的链表：

// 头指针  插入 删除 会有影响 影响指针 

struct Node{
    int data; // 
    struct Node* next; // 下一个的指针
};
 
// 从新定义为 把结构体 指针 去一个别名
// typedef struct Node* LList

// 这个地方是取指针的指针（因为是传的地址）
void init(struct Node** phead){
    *phead =NULL;
}

int getLength(struct Node* head) {
    int len=0;
    // 从头结点一直往后找
    while(head){
        len++;
        head=head->next;
    }
    return len;
}

// 这边是传的指针的值，并不会改变指针
void printlist(struct Node* head){
    while(head){
        printf("%d,",head->data);
        head = head->next;
    }
}
// 创建结点
struct Node* createNode(int x){
    struct Node* t;
    t = (struct Node*)malloc(sizeof(struct Node));
    t->next=NULL;
    t->data =x;
    return t;
}

// 查找元素 第k个 返回 地址
struct Node* findEle(struct Node* phead,int k){
    struct Node* p; // 定义一个指针
    int count=1; // count初值
    p=phead; // 执向的第一个位置
    // 判断p是不是空，计数器不为空
    while(p && count<k){
        p= p->next;
        count++;
    }
    return p;
}

// 插入
// 指针的指针
int insert(struct Node** phead, int k, int x){
     // 找k 就去找k-1的位置，
   
    if(k<1){
        return 0;
    }
    if(k==1){
        // 当插入的是第一个位置的时
        struct Node* t;
        t=createNode(x);
        t->next=*phead;
        *phead= t;
        return 1;
    }
    // struct Node* p; // 定义一个指针
    // int count=1; // count初值
    // p=*phead; // 执向的第一个位置
    // // 判断p是不是空，计数器不为空
    // while(p && count<k-1){
    //     p= p->next;
    //     count++;
    // }
    // 代替上面的
    struct Node* p;
    // zhaok是取找k-1个
    p=findEle(*phead,k-1);
    
    if(p){
         struct Node* t;
        // t = (struct Node*) malloc(sizeof(struct Node));  //创建结点
        t = createNode(x);
        t->next=p->next; // p原先的下一个，让 t的下一个给指向
        p->next =t;
        return 1;
    }else {
        return 0;
    }
}

// 删除

int removeNode(struct Node** phead, int k, int *px){
    // 需要区分头和是不是头
    if(k<1){
        return 0;
    }else if(k==1){
        if(*phead){
            // 头指针不为空，
            *px = (*phead)->data;
            *phead=(*phead)->next;
            return 1;
        }else{
            return 0;
        }
    }else{
        struct Node* p;
        p=findEle(*phead, k-1);
        if(p == NULL || p->next == NULL){
            // 当前为空 ，下一个为空
            return 0;
        }
        struct Node* t;
        t=p->next;
        p->next = t->next;
        *px = t->data;
        free(t); // 释放内存
        return 1;
        
    }
}
// 头结点 两种方式。 插入删除 不会影响指针 ，只是会影响 头结点的next的指针域（值） 



int main(void) { 
    
    struct Node* head; // 链表的头指针
    // 创建一个空链表
    init(&head); // 传地址 
    
    int k=getLength(head);  // 传递的头指针的值
    printf("%d\n",k); // &k 是取的地址。
    int flag=0;
    flag = insert(&head,1,11); // 这里应该传入头指针的地址 在 1号位置插入 11
    flag = insert(&head,1,21);
    flag = insert(&head,1,31);
    
    printf("%d\n",flag);
    
    printlist(head);
    
    int x;
    
    removeNode(&head, 1, &x); //传递的头指针地址
    
    printlist(head);
    
	return 0;
}
```

###### C++

```c++
#include <iostream>
using namespace std;
#include <list>
#include <vector>
#include <stack>
int main() {
    list<int> a;
    a.push_back(11);
    a.push_back(22);
    a.push_back(33);
    a.insert(a.begin(),666);
    for(int i :a ){
        cout << i <<",";
    }
    
    
    // a.erase() // 删除
    // 这个是通过it++相当于 p.next
    list<int>:: iterator it;
    for(it=a.begin(); it!=a.end(); it++){
        cout << &(*it) << "," << *it <<endl;
    }
	return 0;
}
```

###### java

```java
java实现的其实是个双向链表
    public  void test(){
        LinkedList<Integer> linkedList = new LinkedList <>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(4);
        linkedList.clear(); // 清空
        System.out.println(linkedList.get(2));
        System.out.println(linkedList);
    }
// 用java 实现单链表、

package com.kaysanshi.testArray;
/**
 * 链表：是由每个结点和结点数据所组成的链表
 * @author kaysanshi
 *@date 2019年4月25日
 */
public class LinkList {
	//链表的头结点
	private Node first;
	
	public LinkList(){
		first=null;
	}
	/**
	 * 插入节点：在头结点后进行插入
	 * @param value
	 */
	public void insert(long value){
		Node node=new Node(value);
			//把下一个节点的指向添加的节点
			node.next=first;
			//然后把值给first
			first=node;
		
	}
	/**
	 * 删除一个节点，删除的第一个节点
	 * @return
	 */
	public Node deleteFisrt(){
		//把下一个节点给接受
		Node temp=first;
		//然后把这个节点指向第一个节点
		first=temp.next;
		return temp;
	}
	/**
	 * 显示的方法
	 */
	public void display(){
		Node current=first;
		//当前的节点不为null
		while(current!=null){
			current.display();
			current=current.next;
		}
	}
	/**
	 * 查找
	 * @param value
	 * @return
	 */
	public Node find(long value){
		Node current=first;
		while(current.data!=value){
			//下一个没有了终止
			if (current.next==null) {
				return null;
			}
			//指向下一个元素
			current=current.next;
		}
		return current;
	}
	/**
	 * 删除的方法：返回删除的数据
	 * @param value
	 * @return
	 */
	public Node delete(long value){
		//当前的节点
		Node current=first;
		//前一个节点
		Node previous=first;
		while(current.data != value){
			if (current.next==null) {
				return null;
			}
			previous=current;
			current=current.next;
		}
		if (current==first) {
			
			first=first.next;
			
		}else{
			
			previous.next=current.next;
		}
		return current;
	}
}
/**
 * 这是每个节点域
 * @author kaysanshi
 *@date 2019年4月25日
 */
class Node{
	//数据域
	public long data;
	
	//结点域
	//指针域
	public Node next;
	
	//前一个指针域
	public Node privious;
	
	public Node(long value){
		this.data=value;
	}
	/**
	 * 显示的方法
	 */
	public void display(){
		System.out.println(data+" ");
	}
}

```

###### python

python直接使用list就可以了。

####  循环链表：

循环链表：首尾相接的链表称为循环链表

##### 单项循环链表

###### java实现单项循环链表

```java
package com.kaysanshi.testArray;

/**
 * 单链表 循环链表
 * @Author kay三石
 * @date:2020/12/6
 * 对于循环链表而言，关键要素是指定链表的头节点head、尾节点tail以及链表大小size；
 * 该数据结构支持在头部增加节点、在尾部增加节点，从头部删除节点及从尾部删除节点等
 */
public class LinkedListSingleList {
    // 使用的是Node节点

    /**
     *  //数据域
     * 	public long data;
     *
     * 	//结点域
     * 	//指针域
     * 	public Node next;
     *
     * 	//前一个指针域
     * 	public Node privious;
     *
     * 	public Node(long value){
     * 		this.data=value;
     *  }
     */
    private Node head; // 头节点

    private Node tail; // 尾节点

    int size;

    public LinkedListSingleList(){
        this.tail = this.head = null;
        this.size = 0;
    }

    /**
     * 从链表头部增加节点
     * @param node
     */
    public void addNodetoHead(Node node) {
        // 如果使用该方法增加链表的第一个节点，则head=tail=node，且next指向自身
        if(size==0){
            //
            node.next = node;
            tail =head =node;
            size++;
        }else{
            tail.next = node;
            node.next=head;
            size++;
        }
    }

    /**
     * 从链表的尾部增加节点
     * @param node
     */
    public void addNotetoTail(Node node){
        //如果使用该方法增加链表的第一个节点，则tail=head=node，且next指向自身
        if(size==0){
            //
            tail.next = node;
            tail=head=node;
            size++;
        }else{
           tail.next = node;
           node.next = head;
           tail = node;
           size++;
        }
    }

    //删除头部节点，被删掉的head将被自动回收
    public void delHead(){
        if(size>1){
            head = head.next;
            tail.next=head;
            size--;
        }
        else if(size==1){
            head = tail = null;
            size--;
        }
        else{
            System.out.println("There is no elements in the linked list.");
        }
    }

    //删除尾部节点
    public void delTail(){
        if(size>1){
            Node node = new Node();
            node = head;
            while(node.next!=tail){
                node = node.next;
            }
            node.next=head;
            size--;
        }
        else if(size==1){
            head = tail = null;
            size--;
        }
        else{
            System.out.println("There is no elements in the linked list.");
        }
    }

    //打印全部节点
    public void printList(){
        Node node = new Node();
        node = head;
        try{
            while(node.next!=head){
                System.out.print(node.data);
                System.out.print("->");
                node = node.next;
            }
            System.out.print(node.data);
            System.out.print("->");
            System.out.print(head.data);
        }
        catch(Exception e){
            e.printStackTrace();
        }

    }

    public static void main(String[] args){
        // TODO Auto-generated method stub
        LinkedListSingleList lst = new LinkedListSingleList();
        Node head = new Node(11);
        Node head2 = new Node(13);
        lst.addNodetoHead(head);
        lst.addNodetoHead(head2);
        System.out.println("打印链表：");
        lst.printList();

        lst.addNotetoTail(new Node(22));
        lst.addNotetoTail(new Node(33));
        System.out.println("打印链表：");
        lst.printList();
        System.out.println();
        System.out.println("删除首端节点：");
        lst.delHead();
        lst.printList();
        System.out.println();
        System.out.println("删除首端节点：");
        lst.delHead();
        lst.printList();
    }
}

```

###### java实现双向循环链表

**获取节点**

> 由于双向链表有两个可见的节点（head和end），因此双向循环链表获取节点的操作和单链表有所不同。

- 把需要获取的节点序号和链表长度/2比较
- 若小于，说明节点是偏前的，因此从head开始一路next下去
- 若大于，说明节点是偏后的，因此从end开始一路prev上去
- 这样的设计能使getNode操作的时间复杂度缩短为O(logN)

**删除元素**

- 获取待删除元素的节点node
- 把node前一个节点的next指针设置为node的后一个节点。具体实现为：node.prev.next=node.next
- 把node后一个节点的prev指针设置为node的前一个节点。具体实现为：node.next.prev=node.prev
- 由于没有指针指向node,node会被自动清理
- 记录链表长度的变量-1

**插入元素**

- 获取待插入元素的节点node
- 创建一个节点mynode，next指向node，prev指向node.prev
- 把node.prev该节点的next指向mynode
- 把node的前一个节点prev指向mynode

**双向循环链表的优劣**

优势

- 相比单链表，双向循环链表所有基本操作均快于单链表(java源码的LinkList类就是双向循环链表)
- 能直接获取节点的前一个节点，十分灵活

劣势

- 相比单链表，双链表的空间内存明显要大很多

> 双链表的设计应用了算法设计的“空间换时间”思想，通过消耗更多的空间来缩小操作的时间复杂度。

```java
package com.kaysanshi.testArray;

/**
 * 双向循环链表
 * 双向循环链表不只是只有头指针head,还有尾结点end
 * @Author kaysanshi
 * @date:2020/12/6
 */
public class LinkedListTwowaycircular {
    /**
     * 这是每个节点域
     *
     * @author leoill
     * @date 2019年4月25日
     * <p>
     * class Node {
     * //数据域
     * public long data;
     * <p>
     * //结点域
     * //指针域
     * public com.kaysanshi.testArray.Node next;
     * <p>
     * //前一个指针域
     * public com.kaysanshi.testArray.Node privious;
     * <p>
     * public Node(long value) {
     * this.data = value;
     * }
     * <p>
     * public Node() {
     * }
     * <p>
     * public Node(long data, com.kaysanshi.testArray.Node next) {
     * this.data = data;
     * this.next = next;
     * }
     * <p>
     * public Node(long data, com.kaysanshi.testArray.Node next, com.kaysanshi.testArray.Node privious) {
     * this.data = data;
     * this.next = next;
     * this.privious = privious;
     * }
     * }
     */

    Node head;
    Node end;
    int size;
    long t;

    //初始化链表
    public void initlist() {
        end = new Node ();
        head = new Node(0, null, end);
        // 这个地方进行初始化的时候是将下个尾节点的next指向头部
        end.privious = head;
        end.next = head;
        size = 0;
    }

    //获取长度
    public int length() {
        return size;
    }

    //获取节点
    public Node  getNode(int index) {
        Node  n;
        // 判断index是否大于中间的
        if (index >= size / 2) {
            // 若大于，说明节点是偏后的，因此从end开始一路prev上去
            n = end;
            // 获取结点的
            for (int i = length(); i > index; i--) {
                n = n.privious;
            }
            return n;
        } else {
            // 若小于，说明节点是偏前的，因此从head开始一路next下去
            n = head;
            for (int i = 0; i <= index; i++) {
                n = n.next;
            }
            return n;
        }
    }

    //添加元素
    public void add(long a) {
        Node renode = new Node(a, getNode(size - 1), end);
        renode.privious.next = renode;
        renode.next.privious = renode;
        size++;
    }

    //插入元素
    public void insert(int i, long a) {
        // 获取待插入元素的节点node
        Node  n = getNode(i);
        // 创建一个节点newnode，next指向node，prev指向node.prev
        Node newNode = new Node (a, n.privious, n);
        // 把node.prev该节点的next指向新的结点
        n.privious.next = newNode;
        // 把node的前一个节点prev指向新的node
        n.privious = newNode;
        size++;
    }

    //删除元素
    public long remove(int i) {
        // 获取待删除元素的节点node
        Node  n = getNode(i);
        long data = n.data;
        // 把node前一个节点的next指针设置为node的后一个节点
        n.privious.next = n.next;
        // 把node后一个节点的prev指针设置为node的前一个节点
        n.next.privious = n.privious;
        // 由于没有指针指向node,node会被自动清理 令其size减一
        size--;
        return data;
    }

    //获取i位置的数据
    public long get(int i) {
        return getNode(i).data;
    }

    //为i位置元素重新赋值
    public long set(int i, long a) {
        Node  n = getNode(i);
        long old = n.data;
        n.data = a;
        return old;

    }

    //清空链表
    public void clear() {
        initlist();
    }


    public void print() {
        for (int i = 0; i < size; i++) {
            System.out.println(getNode(i).data);
        }
    }

    public static void main(String[] args){
        // TODO Auto-generated method stub
        LinkedListTwowaycircular list = new LinkedListTwowaycircular();
        list.initlist();
        list.add(1);
        list.add(2);
        list.print();
    }
}

```



#### 双向链表：

双链表：结点有两个指针域的链表

##### 双向链表的操作

###### **java实现双向链表**

```java
package com.kaysanshi.testArray;
/**
 * 双向链表
 * @author kaysanshi
 *@date 2019年4月26日
 */
public class DoubleLinkList_double {
	//链表的头结点
			private Node first;
			//尾节点
			private Node last;
			
			public DoubleLinkList_double() {
				// TODO Auto-generated constructor stub
				first=null;
				last=null;
			}
			/**
			 * 从头结点后进行插入 要对链表判断，判断是否weinul。如果weinull.则设置尾结点为新添加的结点；，如果不为null
			 * 设置头结点的前一个结点为新添加的结点
			 * @param value
			 */
			public void insert(long value){
				Node node=new Node(value);
				if (isEmpty()) {
					//把尾节点为第一次添加的
					last=node;
				}else{
					first.privious=node;
				}
				node.next=first;
				first=node;
			}
			/**
			 * 从尾节点进行插入：如果链表为null则直接设置头结点为新添加的结点，否则设置尾结点的后一个结点为新添加结点
			 * 同时设置新添加的节点的前一个结点为尾结点
			 */
			public void insertLast(long value){
				Node node=new Node(value);
				if (isEmpty()) {
					first=node;
				}else{
					last.next=node;
					node.privious=last;
				}
				last=node;
			}
			/**
			 * 从头部删除的第一个节点:判断头结点是否有下一个结点，如果没有则设置尾节点为null,否则设置头结点的下一个结点的
			 * previous为null;
			 * @return
			 */
			public Node deleteFisrt(){
				//把下一个节点给接受
				Node temp=first;
				if (first.next == null) {
					last=null;
				}else{
					first.next.privious=null;
				}
				first=temp.next;
				return temp;
			}
			/**
			 * 删除节点 从尾部删除
			 * 判断头结点是否有下一个结点，如果没有则设置头节点为null,否则设置尾结点的下一个结点的
			 * next为null;
			 */
			public Node deleteLast(){
				Node temp=last;
				if (first.next==null) {
					first=null;
				}else{
					last.privious.next=null;
					
				}
				last=last.privious;
				return last;
			}
			/**
			 * 显示的方法
			 */
			public void display(){
				Node current=first;
				//当前的节点不为null
				while(current!=null){
					current.display();
					current=current.next;
				}
			}
			/**
			 * 查找
			 * @param value
			 * @return
			 */
			public Node find(long value){
				Node current=first;
				while(current.data!=value){
					//下一个没有了终止
					if (current.next==null) {
						return null;
					}
					//指向下一个元素
					current=current.next;
				}
				return current;
			}
			/**
			 * 删除的方法：返回删除的数据
			 * @param value
			 * @return
			 */
			public Node delete(long value){
				//当前的节点
				Node current=first;

				while(current.data != value){
					if (current.next==null) {
						return null;
					}
					
					current=current.next;
				}
				if (current==first) {
					
					first=first.next;
					
				}else{
					current.privious.next=current.next;
				}
				return current;
			}
			/**
			 * 判断weinull
			 * @return
			 */
			public boolean isEmpty(){
				return (first==null);
			}
}

```



###### **java实现双端链表**

```java

/*
 * 实现自己的linkedList;双端链表
 */
public class LinkedList {
	private Node head;//头结点
	private Node last;//尾结点;
	private int size;
	//初始化头尾结点；
	public LinkedList(){
		head=new Node();
		last=head;
	}
	//增加的方法；在链表后增加；
	public boolean add(Object obj){
		Node newNode=new Node();
		newNode.setData(obj);
		last.setNext(newNode);
		last=newNode;
		size++;
		return true;
	}
	//删除的方法；
	public Object remove(int index){
		if(index==0){
			head=head.getNext();
			return null;
		}
		Node before=head;
		for(int i=0;i<index;i++){
			before=before.getNext();
		}
		Node current=before.getNext();
		before.setNext(current.getNext());
		current.setNext(null);
		size--;
		return current.getData();
	}
	//按照属性；删除；
//	 public Object remove(Object item){     
//		 Node before=head;
//		 Object beforeObj=head.getData();
//		for(int i=0;i<size;i++){
//			if(item.equals(beforeObj)){
//				beforeObj=before.getNext().getData();
//				}
//				before=before.getNext();
//			}
//			Node current=before.getNext();
//			Object currentObj=before.getNext().getData();
//			before.setNext(current.getNext());
//			current.setNext(null);
//			before.setData(null);
//			size--;
//			return currentObj;
//	    } 
	//插入的方法；
	 public void insert(int index,Object obj){  
	     Node node=head;  
	     int j=0;  
	     while(node!=null&&j<index-2){  
	         //查找到第index-1个元素  
	         node=node.getNext();  
	         j++; 
	     }  
	     Node sert=new Node();//被插入的结点  
	     sert.setData(obj);
	     sert.setNext(node.getNext());  
	     node.setNext(sert);
	     size++;
	 }
	 
	//改变指定位置的元素 
	 public void modify(int index,Object obj){  
	     Node node=head;  
	     int j=0;  
	     while(node!=null&&j<=index){  
	         //找到第index个结点  
	         node=node.getNext();  
	         j++;  
	     }  
	     node.setData(obj);
	 }
	//查找的方法：无效；
	public Object get(Object obj){
		Node current=head;
		Object objs;
		int j=0;
		while(current.getNext()!=null&&j<=size){
				objs=current.getNext().getData();
				j++;
			if(obj.equals(objs)){
				System.out.println(obj);
				break;
			}else{
				System.out.println("没有这个数据");
				break;
			}
			
		}
		return current.getData();
	}
	//查找按造下标查找；
//	public void find(int index){
//		Node current=head;
//		for(int i=0;i<index;i++){
//			if(){
//				
//			}
//		}
//	}
	@Override
	public String toString() {
        // StringBuffer线程安全类，方法被synchronized关键字修饰
		StringBuffer sb=new StringBuffer();
		//sb.append("[");
		Node currentNode=head;
		while(true){
			if(currentNode.getNext()!=null){
				currentNode=currentNode.getNext();
				sb.append(currentNode.getData()+" ");
			}else{
//				System.out.println("这是个空链表");
				break;
			}
			
		}
		//sb.append("]");
		return sb.toString();
		
	}
	
}
/*
 * 结点类；
 */
public class Node {
	private Object data;//数据域
	private Node next;//引用，指针域
	public Node() {
		super();
	}
	public Node(Object data, Node next) {
		super();
		this.data = data;
		this.next = next;
	}
	public Object getData() {
		return data;
	}
	public void setData(Object data) {
		this.data = data;
	}
	public Node getNext() {
		return next;
	}
	public void setNext(Node next) {
		this.next = next;
	}

}

```



|                | **顺    序  表**                                             | **链    表**                                              |
| -------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| **存储空间**   | **预先分配，会导致空间闲置或溢出现象**                       | **动态分配，不会出现闲置或溢出现象**                      |
| **存储密度**   | **不用为表示结点间的逻辑关系而增加额外的存储开销，存储密度等于 1** | **需要借助指针来体现元素间的逻辑关系，存储密度小于 1**    |
| **存取元素**   | **随机存取，时间复杂度为 O(1)**                              | **顺序存取，时间复杂度为 O( *n *)**                       |
| **插入、删除** | **平均移动约表中一半元素，时间复杂度为 O( *n *)**            | **不需移动元素，确定插入、删除位置后，时间复杂度为 O(1)** |
| **适用情况**   | **①** **表长变化不大，且能事先确定变化的范围**   **② 很少进行插入或删除操作，经常按元素序号访问数据元素** | **①** **长度变化较大**   **② 频繁进行插入或删除操作**     |

#### 栈

##### 定义

栈：只能在表的一端（栈顶）进行插入和删除运算的线性表

**逻辑结构：**与线性表相同，任然是一对一关系

**存储结构：**用顺序栈或链栈存储都可以。

**运算规则：**只能在栈顶运算，且访问结点时依照后进先出或者先进后出的原则。

**实现方式：**关键是编写入栈和出栈的函数。

[![DjY1QU.png](https://s3.ax1x.com/2020/12/06/DjY1QU.png)](https://imgchr.com/i/DjY1QU)



##### 顺序栈的表示：

[![DjtbuD.png](https://s3.ax1x.com/2020/12/06/DjtbuD.png)](https://imgchr.com/i/DjtbuD)

```c
#define  MAXSIZE  100
typedef struct{
		SElemType   *base;
		SElemType   *top;
		int stacksize;
}SqStack;

// 初始化
Status InitStack( SqStack &S ){
	S.base =new SElemType[MAXSIZE]；
	if( !S.base ) 	return OVERFLOW;
	S.top = S.base;
	S.stackSize = MAXSIZE;
	return OK;
}
// 顺序栈是否为空
bool StackEmpty( SqStack S ){
	if(S.top == S.base) return true;
   else return false;
}
// 顺序栈的长度
int StackLength( SqStack S ){
	return S.top – S.base;
}
// 清空顺序栈
Status ClearStack( SqStack S ){
	if( S.base ) S.top = S.base;
	return OK;
}
// 销毁顺序栈
Status DestroyStack( SqStack &S ){
	if( S.base )
	{
		delete S.base ;
		S.stacksize = 0;
		S.base = S.top = NULL;
	}
  return OK;
}
// 顺序栈进站
// (1)判断是否栈满，若满则出错
// (2)元素e压入栈顶
// (3)栈顶指针加1
Status Push( SqStack &S, SElemType e){
	if( S.top - S.base== S.stacksize ) // 栈满
        return ERROR; 	
	*S.top++=e;
	return OK;
}
// 顺序进站
// (1)判断是否栈空，若空则出错
// (2)获取栈顶元素e
// (3)栈顶指针减1
Status Pop( SqStack &S, SElemType &e)  
{
	if( S.top == S.base ) // 栈空
        return ERROR; 	
	e＝ *--S.top;
	return OK;
}
// 取顺序栈栈顶元素
// 判断是否空栈，若空则返回错误
// 否则通过栈顶指针获取栈顶元素
Status GetTop( SqStack S, SElemType &e)  {
	if( S.top == S.base )	 return ERROR; 	// 栈空
	e = *( S.top – 1 );
	return OK;
}




```

##### 顺序栈的操作

###### c语言

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

struct Stack{
    int *data; // 数据
    int capacity;// 最大容量
    int top;// 栈顶
};
// 判断栈满
int isFull(const struct Stack *ps){
    // 满就是top是否与capacity相同
    return ps->top == ps->capacity; 
}
// 判断栈空
int isEmpty(const struct Stack *ps){
    // top为0是空栈
    return ps->top == 0;
}
// 
int top(const struct Stack *ps){
    if(isEmpty(ps)) return 0;
    else{
        *ps = ps->data[--(ps->top-1)];
    	return 1;
    }
    
}
// init
void init(struct Stack *ps,int capacity){
    ps->capacity = capacity; // 初始化容量
    ps->data = (int *)malloc( sizeof(capacity));
    // ps->top = -1; // 总是指向最高元素 
    ps->top = 0; // 总是指向最高元素的上面的空格
}
// 压栈
int push(struct Stack *ps, int x){
    // 判断栈满
    if(isFull(ps)) return 0;
    else{
        // 进行压栈
        ps->data[ps->top++]=x;
        return 1;
    }
    
}
// 弹栈
int pop(struct Stack *ps, int x){
    if(isEmpty(ps)) return 0;
    else{
     *ps = ps->data[--(ps->top)];
      return 1;   
    }
    
}
// 销毁
void destory(struct *ps){
    free(ps->data);
}
int main(void) { 
    struct Stack st;
    
    init(&st，5); // 改变st的内容，所以需要st地址 &st 
    
    push(&st, 11); // 压栈
    push(&st, 121); // 压栈
    push(&st, 111); // 压栈
    push(&st, 131); // 压栈
    int x;
    pop(&st, &x); // 弹栈 并把弹出的数据返回
    
    destory(&st);
    
	return 0;
}
```

###### C++

```c++
#include <iostream>
#include <stack>
using namespace std;
int main(int argc,const char * args[]){
	stack<int> st;
	st.push(11);
	st.push(12);
	int x = st.top();
	st.pop()//弹栈
	st.empty();
    cout << st.size() << endl;
	return 0;
}
```

###### java

```java

public class ArrayStackDemo {
	public static void main(String[] args) {
		//测试
		ArrayStack stack =new ArrayStack(4);
		String key="";
		boolean loop = true;
		Scanner scanner = new Scanner(System.in);
		
		while(loop) {
			System.out.println("show:表示显示栈");
			System.out.println("exit:退出程序");
			System.out.println("push:表示添加数据到栈（入栈）");
			System.out.println("pop:表示从栈取出数据（出栈）");
			System.out.println("请输入你的选择");
			key = scanner.next();
			switch(key) {
			case "show":
				stack.list();
				break;
				
			case "push":
				System.out.println("请输入一个数");
				int value = scanner.nextInt();
				stack.push(value);
				break;
				
			case "pop":
				try {
					int res = stack.pop();
					System.out.printf("出栈的语句是%d\n", res);
				}catch(Exception e) {
					System.out.println(e.getMessage());
				}
				break;
				
			case "exit":
				scanner.close();
				loop = false;
				break;
			default:
					break;
			}
		}
		System.out.println("程序退出");
	}
 
}
 
class ArrayStack{
	private int maxSize;
	private int[] stack;
	private int top = -1;
	
	
	public ArrayStack(int maxSize) {
		this.maxSize=maxSize;
		stack = new int[this.maxSize];
		
	}
	
    //栈满
	public boolean isFull() {
		return top == maxSize -1;
		
	}
    //栈空
	public boolean isEmpty() {
		return top == -1;
		
	}
	//出栈
	public void push(int value) {
		if(isFull()) {
			System.out.println("栈满");
		}
		top++;
		stack[top] =value;
		}
	//出栈
	public int pop() {
		if(isEmpty()) {
			throw new RuntimeException("栈空");
		}
		int value = stack[top];
		top--;
		return value;
	}
	//遍历栈
	public void list() {
		if(isEmpty()) {
			System.out.println("栈空，没有数据");
			return;
		}
		for(int i = top;i>=0;i--) {
			System.out.printf("stack[%d]=%d\n",i,stack[i]);
		}
	}

```

######  python

```python
st = list()
st.append(11)
st.append(22)
st.append(33)
x = st.pop(1) // 弹出1号元素
st.pop() // 弹出最后一个进栈的

```

##### 后缀式求值

后缀式 3 5 2 1 - * + 思路 就是需要一个栈

```python
class Solution:
    def cal(x,y,op):
        if op=='+':
            return x+y
        elif op == '-':
            return x-y
        elif op == '*':
            return x*y
        elif op == '/':
            return x/y

    def evalRPN(self, tokens: List[str]) -> int:
            """
        :type tokens: List[str]
        :rtype: int
        """
        for i in tokens:
            if i in '+-*/':
                b = tokens.pop()
                a = tokens.pop() 
                tokens.append(cal(a,b,i))
            else:
                tokens.append(float(i))
        print('%.1f' % tokens.pop())
        
        
```

```java
class Solution {
    public int evalRPN(String[] tokens) {
    String operators = "+-*/";
        Stack<Object> stack = new Stack<>();
        for(int i=0;i<tokens.length;i++){
            String op = tokens[i];//取出一个操作
            if(operators.contains(op)){//如果是操作符
                int n2 = (int) stack.pop();
                int n1 = (int) stack.pop();
                int value = 0;
                switch (op){
                    case "+":value = n1 + n2;break;
                    case "-":value = n1 - n2;break;
                    case "*":value = n1 * n2;break;
                    case "/":value = n1 / n2;
                }
                stack.push(value);//把值送入栈
            }
            else {//如果是操作数
                stack.push(Integer.valueOf(op));//操作数入栈
            }
        }
        return (int) stack.pop();//最后栈顶的操作数就是运算结果了
    }
}
```



#### 队列

##### 定义

**队列是一种先进先出(FIFO)的线性表**.**在表一端插入在另一端删除**

只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表

**逻辑结构：**与线性表相同，任为一对一关系。

**存储结构：**用顺序队列或链队存储均可。

**运算规则：**先进先出FIFO

**实现方式：**关键是编写入队和出队函数，具体实现实现依顺序队或的不同而不同。

##### 队列的操作

###### C语言

```

```



#### 循环队列

##### 循环队列的定义

##### 循环队列的操作

###### C语言

```c
#include <stdio.h>
#include <stdlib.h>
struct Queue{
int *data
int capacity; //容量
int front; // 队头
int rear; // 队尾
}
// 指定容量,初始话数据
void init(struct Queue *pq,int capacity){
    pq->capacity = capacity;
    pq->data=(int*)malloc(sizeof(int)*(capacity+1));
    // 初始队头和队尾
    pq->front=pq->rear=0;
}
//队是否满
int isFull(const struct Queue *pq){
    // 取余操作 循环
    if((pq->rear+1)%(pq->capacity+1) == pq->front) return 1;
    else return 0;
}
int isEmpty(const struct Queue *pq){
    return pq->front == pq->rear;
}
//入队
int enQueue(struct Queue *pq,int capacity){
    if(isFull(pq)) return 0;
    else{
        pq->data[pq->rear]=x;
        pq->rear =(pq->rear+1) % (pq->capacity+1);
        return 1;
    }
}
//出队e
int delQueue(struct Queue *pq, int *px){
    if(isEmpty(pq)) return 0;
    else{
        *px = pq->data[pq->front];
        pq->front = (pq->front+1)%(pq->capacity+1);
        return 1;
    }
}
int main(){
    struct Queue q;
    init(&q,5);
    // 入队
    enQueue(&q,11);
    // 出队
    int x;
    delQueue(&q,&x);
    return 0;
}
```

###### C++

```c++
#include <isostream>
using namespace std;
struct Node{
    int data;
    Node* next;
     Node(int x){
        data=x;
        next=NULL;
    }
}
class Queue{
    // 作为一个私有对象
private:    
    Node* front; // 队头
    Node* rear; // 队尾
   
public:
    Queue(){
        //不带空头节点的链表，空指针
        front = real=NULL;
    }
    // 定义一个析构函数释放内存
    ~Queue(){
        Node* tmp;
        while(front){
            tmp = front;
            front=front->next;
            delete tmp;
        }
    }
    bool isEmpty(){
        return front ==NULL; // front为null就是空
    }
    // 入队
    void enQueue(int x){
        Node *tmp;
        tmp=new Node();
        if(isEmpty()){
            cout << "empty" << tmp->data << endl;
            front=rear=tmp;
        }else{
            // 队列不为空时
            rear->next=tmp;
            rear = rear->next; // 等价于 rear = tmp
        }  
    }
    // 出队
    bool delQueue(int *px){
        // 使用指针
        if(isEmpty()) return false;
        else{
            //获取队首元素
            *px= front->data;
            // 把头节点删除
            Node* tmp;
            tmp = front;
            front = front->next;
            delete tmp;
            // 当出队时为null时 则rear也要为null
            if(front==NULL) rear=NULL;
            return true;
        }
    }
}

int main(int argc,const char *argv[]){
    
    return 0;
}
```

###### C++自带的

```c++
#include <isostream>
#include <queue>
using namespace std;
int main(int argc,const char *argv[]){
    queue<int> q;
    q.push(11); // 增加元素
    q.push(12);
    q.pop();// 出队
    int x=q.front();// 查看队首元素
    return 0;
}
```

###### java

```java
public static void main(String[] args){
    // 链表实现了对例的操作
    Queue<Integer> q= new LinkedList<>();
    q.add(11);
    q.add(12);
    q.add(13);
    System.out.println(q.peek());// 查看队首元素
    System.out.println(q.poll());// 出队
}
```

##### 简单模拟单队列排队

**题目**

设某银行有一个固定能容纳N个顾客的等候区，顾客想进银行，若等候区有空则可进，否则被拒绝进入。
每当银行柜员叫号时，等候区中最先进入的顾客离开等候区前往柜台办理业务，若叫号时等候区无人，则此次叫号作废

**输入**

第一行输入一个不大于20的正整数N，表示银行等候区能容纳的人数，
接下来用若干行表示依时间顺序先后发生的“顾客想进银行”或“叫号”事件，格式分别是：

顾客想进银行，用 In 表示，其中是顾客编号，为不大于100000的正整数； 叫号，用Calling表示。
最后一行是一个#符号，表示输入结束。

**输出**

顾客想进银行，若顾客进入，则输出 joined. Total: 其中是该顾客的编号，是顾客进入后，等候区的人数
顾客想进银行，若因等候区满而被拒绝，则输出 rejected. 其中是该顾客的编号 叫号，若有顾客前往柜台，则输出
called. Total: 其中是该顾客的编号，是顾客去柜台后，等候区的人数 叫号，等候区无人，则输出 No
one!

###### C语言

```c
#include <stdio.h>
#include <stdlib.h>
struct Queue{
int *data
int capacity; //容量
int front; // 队头
int rear; // 队尾
int size;
}
// 指定容量,初始话数据
void init(struct Queue *pq,int capacity){
    pq->capacity = capacity;
    pq->data=(int*)malloc(sizeof(int)*(capacity+1));
    // 初始队头和队尾
    pq->front=pq->rear=0;
    pq->size=0;
}
//队是否满
int isFull(const struct Queue *pq){
    // 取余操作 循环
    if((pq->rear+1)%(pq->capacity+1) == pq->front) return 1;
    else return 0;
}
int isEmpty(const struct Queue *pq){
    return pq->front == pq->rear;
}
//入队
int enQueue(struct Queue *pq,int capacity){
    if(isFull(pq)) return 0;
    else{
        pq->data[pq->rear]=x;
        pq->rear =(pq->rear+1) % (pq->capacity+1);
        pq->size++;
        return 1;
    }
}
//出队e
int delQueue(struct Queue *pq, int *px){
    if(isEmpty(pq)) return 0;
    else{
        *px = pq->data[pq->front];
        pq->front = (pq->front+1)%(pq->capacity+1);
        pq->size--;
        return 1;
    }
}
int main(){
   int N;
    scanf("%d",&N);
    struct Queue q;
    init(&q,N);
    char op[20];
    int id;
    scanf("%s",op);
    // 如果op的0号元素不是#
    while(op[0] !='#'){
        if(op[0]=='I'){
            // 如果是IN+id
            scanf("%d",&id);
            if(isFull(&q)){
               // 如果对列满了
                printf("%d rejected.\n",id);
            }else{
                enQueue(&q,id);
                printf("%d joined. Total:%d",id,q.size);
            }
        }else{
            // 如果是Calling+id
            if(isEmpty(&q)){
                printf("No one!\n");
            }else{
                delQueue(&q,&id);
                printf("%d called. Total:%d",id,q.size) 
            }
        }
        scanf("%s",op);
    }
    return 0;
}
```

###### C++

```c++
#include<stdio.h>
#include<iostream>
#include<queue>
#include<string>

using namespace std;
//总体来说，还是简单的题，队列的简单出队和入队操作 
int main(){
	queue<int> q;
	
	int N;
	string str;
	scanf("%d",&N);
	int tem;
    while(getline(cin,str),str !="0"){
    	tem = 0 ; 
    	if(str[0] == '#') break;         // 结束符
    	else if(str == "Calling"){//叫号
			if(!q.empty()){
				tem = q.front();
				q.pop();
				printf("%d called. Total:%d\n",tem,q.size());
			}else{
				printf("No one!\n");
			}	
		}else{
    		for(int i =0;i<str.length();){
    			if(str[0] == 'I' && str[1] == 'n'){//入队
    				i +=2;
    				if(str[i] == ' ')i++;
    				tem = str[i++] - '0';
    
    				while(i<str.length() && str[i] >= '0' && str[i] <= '9'){
    					tem = tem * 10  + (str[i] - '0');
    					i++;
					}
    				if(q.size() < N){
						q.push(tem);
						printf("%d joined. Total:%d\n",tem,q.size());
					}else{
						printf("%d rejected.\n",tem);
					}
    			
				}
			
			}
		}
	}
	return 0;
}

```

###### java

```java
public static void main(String[] args){
    Scanner in = new Scanner(System.in);
    int N= in.next();
    Queue<String> q=new LinkedList();
    String op,id;
    op= in.next();
    while(!op.equals("#")){
        if(op.equals("In")){
            id= in.next();
            if(q.size() == N){
                System.out.println(id+" rejected.");
            }else{
                q.offer(id);
                System.out.println(id+" joined. Total:"+q.size());

            }
        }else{
            if(q.isEmpty()){
                System.out.println("No one!");
            }else{
                id=q.poll();
                System.out.println(id+"called. Total:"+q.size());
            }
        }
        op= in.next();
    }
 in.close();

}
```

#### 链式队列

##### 链式队列的定义

##### 链式队列的操作

### 树

**树（Tree）是**n**（**n≥0**）个结点的有限集，它或为空树（**n= 0）；或为非空树，对于非空树**T：**

**（1**）有且仅有一个称之为根的结点；

**（2**）除根结点以外的其余结点可分为不同的子树。

 * 结点：树的数据元素

 * 结点的度：结点挂接的子树数

 * 结点的层次：从根节点到该结点的层数

 * 路径：顺着连接节点的边从一个节点到另一个节点，所经历的节点顺序

 * 根节点：树最上面的节点称为根节点，一棵树只有一个根，而且根到任何一个节点有且只有一条路径

 * 父节点：每个节点都有一条边向上连接到另一个节点，这个节点就称是下面的节点的父节点

 * 子节点：每个节点都有一条边向下连接到另一个节点，下面的节点称为该节点的子节点

 * 叶子节点：没有子节点的节点称为叶子节点

 * 子树：每个节点都可以作为一个子树的根，它和它所有的子节点，子节点的节点组合起来就是一个子树

 * 遍历：先序，中序，后序

 * 前序：1.访问根节点,2，左子树，3.右子树

 * 中序：左 ，根， 右

 * 后序 左，右，根

 * 访问：访问一个节点是为了在这个节点上执行一些操作，如查看节点的数据项，但是如果仅仅是经过一个节点，不认为是访问了这个节点

 * 层:一个节点的层数是指从根节点开始到这个节点有多少代

 * 树的度：所有结点度中的最大值

 * 树的深度：值所有结点中最大的层数

   

#### 二叉树

##### 定义：

是n个结点所构成的集合。

树的节点最多有两个子节点，称为二叉树

##### 特点

结点的度小于等于2

有序树  查找效率O(n)

##### 性质

在二叉树的第i层上至多有2^i-1个结点。第i层上至少有1个结点

深度为k的二叉树至多有2^k -1个结点，深度为k时至少有k个结点

对于任何一颗二叉树，若度为2的结点树有n2个则叶子树n0必定为n2+1（即 n0=n2+1）

具有n个结点的完全二叉树的深度必为log2n+1   以2为底的n次方的对数+1 

对于完全二叉树，若从上至下，从左至右编号，则编号为i的结点，其左孩子编号必为2i，其右孩子的编号必为2i+1，其双亲的编号必为i/2

##### 满二叉树

一棵深度为k且有2^k -1个结点的二叉树（特点：每层都充满了结点）满二叉树是完全二叉树的一个特例

##### 完全二叉树

深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中的编号从1到n的结点一一对应。

##### 二叉树的遍历

[![sDJ30f.png](https://s3.ax1x.com/2021/01/16/sDJ30f.png)](https://imgchr.com/i/sDJ30f)

DLR - 先序遍历， 即先根在左再右。 A B D E C

LDR - 中序遍历，即先左再根再右。 D B E A C

LRD - 后序遍历，即先左再右再根。 D E B C A

#### 二叉树的实现（递归实现）

##### c语言

```c
#include <stdio.h>
#include <stdlib.h>
typedef int Elem;
struct BinNode{
    Elem data;
    struct BinNode *left;
    struct BinNode *right;
}
typedef struct BinNode* BinTree;
// 初始化
BinTree initBinTree(Elem x){
    BinTree r;
    r = (BinTree) malloc(sizeof(struct BinNode));
    r->data = x;
    r->left = r->right=NULL;
    return r;
}
// 先序遍历(递归)
void preprint(BinTree r){
    if(r==NULL) return;
    printf("%d ",r->data);
    preprint(r->left);
    preprint(r->right);
}
//中序遍历(递归)
void inreprint(BinTree r){
    if(r==NULL) return;
    inreprint(r->left);
    printf("%d ",r->data);
    inreprint(r->right);
}
//后续遍历(递归)
void afterreprint(BinTree r){
    if(r==NULL) return;
    afterreprint(r->left);
    afterreprint(r->right);
    printf("%d ",r->data);
}
// 根结点，左子树 右子树 （先序遍历）
BinTree findX(BinTree r, Elem x){
    if(!r) return NULL;
    if(r->data == x) return r;
    BinTree found;
    found = findX(r->left,x);
    return found ? found : findX(r->right,x);
}
//打印树和其深度
void printTree(BinTree r, int depth){
    for(int i=0;i<depth;i++) printf(" ");
    if(!r){
        printf("[/]\n");
    }else{
        printf("%d\n",r->data);
        printTree(r->left,depth+1);
        printTree(r->right,depth+1);
    }
}
// 插入
int insert(BinTree bt,Elem p, int LorR,Elem x){
    BinTree found;
    found = findX(bt,p);
    if(LorR == 0){
        if(found->left) return 0;
        found->left = initBinTree(x);
    }else{
        if(found->right) return 0;
        found->right = initBinTree(x);
    }
    return 1;
}
int main(){
    BinTree bt = initBinTree(11);
    insert(bt,11,0,22);
    insert(bt,11,1,33);
    insert(bt,22,0,44);
    insert(bt,33,0,55);
    printTree(bt,0);
    preprint(bt);
    return 0;
}
```

##### c++

```c++
#include <iostream>
using namespace std;
//使用模板
template<class Elem>
struct BinNode{
    Elem data;
    BinNode<Elem> *left;
    BinNode<Elem> *right;
    BinNode(Elem x){
    	data = x;
    	left=right=NULL;
    }
};
template<class Elem>
class BinTree{
protected:
    BinNode<Elem> *root;
    // 先序遍历(递归)
    void rereprint(BinNode<Elem> *r){
    	if(r==NULL) return;
    	//先访问根。递归访问左子树，递归访问右子树
    	cout << r->data << ' ';
    	rereprint(r->left);
    	rereprint(r->right);
    }
    // 中序遍历(递归)
    void reinprint(BinNode<Elem> *r){
    	if(r==NULL) return;
    	// 递归访问左树,访问根结点，遍历右子树
    	reinprint(r->left);
    	cout << r->data << ' ';
    	rereprint(r->right);
    }
    // 后续遍历(递归)
    void reafterprint(BinNode<Elem> *r){
    	if(r==NULL) return;
    	// 递归访问左树,遍历右子树,访问根结点，
    	reafterprint(r->left);
    	reafterprint(r->right);
    	cout << r->data << ' ';
    }
    //递归查找
    BinNode<Elem>* rfindX(Elem x ,BinNode<Elem> *root){
    	if(!root) return NULL;
		if(root->data == x) return root;
		BinNode<Elem> *found;
		found = rfindX(x,r->left);
		return found ? found : rfindx(x,x->right);
    }
    // 打印 以规定的形势
    void rprint(BinNode<Elem> *root,int depth){
    	
    	for(int i=0;i<depth;i++) cout << " ";
    	if(!root) {
    		cout<< "[/]" << endl;
    	}else{
    		cout << r->data<<endl;
    		rprint(r->left,depth+1);
    		rprint(r->right,depth+1);
    	}
    	
    }
public:
	BinNode(){ root = NULL;}
	// 构造函数
	BinTree(Elem r){
		root = new BinNode<Elem>(r);
	}
	// 析构函数
	~BinTree(){}
	// 先序遍历
	void preprint(){
		rereprint(root);
		cout << endl;	
	}
	// 中序遍历
	void inprint(){
		reinprint(root);
	}
	// 后续遍历
	void reafterprint(){
		reafterprint(root);
	}
	// 查找元素返回结点的地址
	BinNode<Elem>* findX(Elem x){
		return rfindX(x,root)
	}
	// 插入
	bool insert(Elem parent,int leftOrRight,Elem x){
		BinNode<Elem> *found;
		found = findX(parent);
		// 如果found不为null
		if(!found) return false;
		if(leftOrRight == 0){
			if(found->left) return false;
			found->left = new BinNode<Elem>(x);
		}else{
			if(found->right) return false;
			found->right = new BinNode<Elem>(x);
		}
		return true;
	}
	// 打印
	void print(){
		rprint(root,0)
	}
};
int main(){
    BinTree<int> bt(11);
    // 插入结点 在结点为11的，0是左子树，插入元素22
    bt.insert(11,0,22);
    bt.insert(11,0,33);
    bt.insert(33,0,44);
     // 打印树先序
    bt.preprint();
    // 中序
    bt.inprint();
    // 后续
    bt.reafterprint();
    return 0;
}
```

##### python

```python
class BinNode:
    def _init_(self,data):
        self.data=data;
        self.left = None;
        self.right = None;
class BinTree:
    def _init_(self,data):
		self.root = BinNode(data);
    def preprint(self,r):
        if r is None:
            return
        print(r.data,end=' ');
        self.preprint(r.left)
        self.preprint(r.right)
    def findX(self, r, x):
        if r is None:
			return
        if r.data == x:
           return r
        found = self.findX(r.left,x)
        if found is not None :
           return found
        return self.findX(r.right,x)
    # 插入 root ,parent ,是否是左子树，元素
    def insert(self,r,p,lorr,x):
        found = self.findX(r,p)
        if found is None:
            return
        if lorr == 0:
            if found.left is not None:
                return
            found.left =BinNode(x)
         else:
            if found.right is not none:
                return
            found.right =BinNode(x)
bt=BinTree(11)
bt.insert(bt,root,11,0,22)
bt.insert(bt,root,11,1,33)
bt.insert(bt,root,22,1,44)
bt.insert(bt,root,22,0,55)
bt.preprint(bt.root)
```



##### java

```java
package com.kaysanshi.testArray;

import org.omg.CosNaming.NamingContextExtPackage.StringNameHelper;

/**
 * 树中能够快速的查找数据项，和插入数据项，删除数据项
 * 树的概念：
 * 路径：顺着连接节点的边从一个节点到另一个节点，所经历的节点顺序
 * 根节点：树最上面的节点称为根节点，一棵树只有一个根，而且根到任何一个节点有且只有一条路径
 * 父节点：每个节点都有一条边向上连接到另一个节点，这个节点就称是下面的节点的父节点
 * 子节点：每个节点都有一条边向下连接到另一个节点，下面的节点称为该节点的子节点
 * 叶子节点：没有子节点的节点称为叶子节点
 * 子树：每个节点都可以作为一个子树的根，它和它所有的子节点，子节点的节点组合起来就是一个子树
 * 遍历：先序，中序，后序
 * 前序：1.访问根节点,2，左子树，3.右子树
 * 中序：左 ，根， 右
 * 后序 左，右，根
 * 访问：访问一个节点是为了在这个节点上执行一些操作，如查看节点的数据项，但是如果仅仅是经过一个节点，不认为是访问了这个节点
 * 层:一个节点的层数是指从根节点开始到这个节点有多少代
 * 二叉树：
 * 树的节点最多有两个子节点，称为二叉树
 *
 * @author leoill
 * @date 2019年4月28日
 */
public class Tree {
    //根
    private TreeNode root;

    /**
     * 插入节点：
     * 从根节点开始查找一个相应的节点，这个节点将称为新插入的节点的父节点。
     * 当父节点找到后通过判断新节点值的大小决定连接在左节点还是右节点
     *
     * @param value
     */
    public void insert(long value) {
        //封装节点
        TreeNode node = new TreeNode(value);
        //引用当前节点
        TreeNode current = root;
        //引用父节点

        TreeNode parent;
        //如果root为null，也就是第一个插入的时候
        if (root == null) {
            root = node;
            return;
        } else {
            while (true) {
                //父节点指向当前的节点
                parent = current;
                //如果当前的指向的节点的数据比插入的大，则向左走
                if (current.data > value) {
                    current = current.leftChild;
                    if (current == null) {
                        parent.leftChild = node;
                        return;
                    }
                } else {
                    current = current.rightChild;
                    if (current == null) {
                        parent.rightChild = node;
                        return;
                    }
                }

            }
        }
    }

    /**
     * 两个参数的
     *
     * @param value
     */
    public void insert(long value, String string) {
        //封装节点
        TreeNode node = new TreeNode(value, string);
        //引用当前节点
        TreeNode current = root;
        //引用父节点

        TreeNode parent;
        //如果root为null，也就是第一个插入的时候
        if (root == null) {
            root = node;
            return;
        } else {
            while (true) {
                //父节点指向当前的节点
                parent = current;
                //如果当前的指向的节点的数据比插入的大，则向左走
                if (current.data > value) {
                    current = current.leftChild;
                    if (current == null) {
                        parent.leftChild = node;
                        return;
                    }
                } else {
                    current = current.rightChild;
                    if (current == null) {
                        parent.rightChild = node;
                        return;
                    }
                }

            }
        }
    }

    /**
     * 查找节点
     *
     * @param value
     */
    public TreeNode find(long value) {
        //引用一个当前节点，从根节点开始
        TreeNode current = root;
        //循环：只要查找的节点不等于当前节点的数据项
        while (current.data != value) {
            //进行比较，小于value则在右子树查找，否则在左边查找
            if (current.data > value) {
                current = current.leftChild;
            } else {
                current = current.rightChild;
            }
            if (current == null) {
                return null;
            }
        }
        return current;
    }

    /**
     * 删除二叉树节点
     * 删除之前首先要查找要删的节点，找到节点后，这个删除的节点可能有以下情况
     * 1.该节点是叶子节点，没有子节点：要删除叶节点，只需改变该节点的父节点的引用，将指向该节点的引用设置为null就可以了
     * 2.该节点有一个子节点：改变父节点的引用，将其指向要删除的节点的子节点、
     * 3.该节点有两个子节点，要删除有两个子节点的节点，就需要使用它的中序后继来替代该节点
     *
     * @param value
     * @return
     */
    public boolean delete(long value) {
        //引用当前节点，从根节点开始
        TreeNode current = root;
        //应用当前节点的父节点
        TreeNode parent = root;
        //是否为左节点
        boolean isLeftNode = true;
        while (current.data != value) {
            parent = current;
            //这里是比较当前的值和当前节点的大小
            if (current.data > value) {
                //如果当前值大于删除的值，则则向左面查找
                current = current.leftChild;
                isLeftNode = true;
            } else {
                //如果当前值小于删除的值则向右面查找，直到找到
                current = current.rightChild;
                isLeftNode = false;
            }
            //如果找不到
            if (current == null) {
                return false;
            }
        }
        //删除叶子节点，也就是该节点没有子节点
        if (current.leftChild == null && current.rightChild == null) {
            //如果是根
            if (current == root) {
                root = null;
                //如果 它是父节点的左子节点
            } else if (isLeftNode) {
                parent.leftChild = null;
            } else {
                parent.rightChild = null;
            }

            //删除的节点只有左子节点
        } else if (current.rightChild == null) {
            if (current == root) {
                root = current.leftChild;
            } else if (isLeftNode) {
                parent.leftChild = current.leftChild;
            } else {
                parent.rightChild = current.leftChild;
            }
            //删除的节点只有右子节点
        } else if (current.leftChild == null) {
            if (current == root) {
                root = current.rightChild;
            } else if (isLeftNode) {
                parent.leftChild = current.rightChild;
            } else {
                parent.rightChild = current.rightChild;
            }
            //删除的节点
        } else {
            TreeNode successor = getSuccessor(current);
            if (current == root) {
                root = successor;
            } else if (isLeftNode) {
                parent.leftChild = successor;
            } else {
                parent.rightChild = successor;
            }
            successor.leftChild = current.leftChild;
        }

        //表示删除成功
        return true;

    }

    /**
     * 中序后继节点，
     *
     * @param delNode
     * @return
     */
    public TreeNode getSuccessor(TreeNode delNode) {
        TreeNode successor = delNode;
        TreeNode successorParent = delNode;
        TreeNode current = delNode.rightChild;
        while (current != null) {
            successorParent = successor;
            successor = current;
            current = current.leftChild;

        }
        if (successor != delNode.rightChild) {
            successorParent.leftChild = successor.rightChild;
            successor.rightChild = delNode.rightChild;
        }

        return successor;
    }

    /**
     * 前序遍历:前序：1.访问根节点,2，左子树，3.右子树
     * 使用递归遍历
     *
     * @param localNode
     */
    public void frontTraversal(TreeNode localNode) {
        if (localNode != null) {
            //访问根节点
            System.out.println(localNode.data + "," + localNode.sdata);
            //前序遍历左子树
            frontTraversal(localNode.leftChild);
            //前序遍历右子树
            frontTraversal(localNode.rightChild);
        }
    }

    /**
     * 中序遍历
     * 递归遍历
     * 中序：左 ，根， 右
     * 就是会从小到大一次排列
     *
     * @param localNode
     */
    public void centerTraversal(TreeNode localNode) {
        //先中序遍历左子树
        if (localNode != null) {
            //中序遍历左子树
            centerTraversal(localNode.leftChild);
            //访问根节点
            System.out.println(localNode.data + "," + localNode.sdata);
            //中序遍历右子树
            centerTraversal(localNode.rightChild);
        }
    }

    /**
     * 后序遍历:
     * 左 ,右,根
     *
     * @param localNode
     */
    public void lastTraversal(TreeNode localNode) {
        if (localNode != null) {
            //后序遍历左子树
            lastTraversal(localNode.leftChild);
            //后序遍历右子树
            lastTraversal(localNode.rightChild);
            //访问根节点
            System.out.println(localNode.data + "," + localNode.sdata);
        }
    }


    /**
     * 测试
     *
     * @param args
     */
    public static void main(String[] args) {
        Tree tree = new Tree();
        tree.insert(1, "zhang");
        tree.insert(12, "ASD");
        tree.insert(13, "BHD");
        tree.insert(14, "HUA");
        tree.insert(10, "DOS");
        tree.insert(11, "NOD");
        tree.centerTraversal(tree.root);
        //删除子节点没有
        tree.delete(1);
        System.out.println();
        tree.centerTraversal(tree.root);
        System.out.println();
        //删除删除该节点有一个子节点
        tree.delete(11);
        tree.centerTraversal(tree.root);
        System.out.println();
        //删除
        tree.delete(14);
        tree.centerTraversal(tree.root);
    }

}

/**
 * 二叉树节点
 *
 * @author leoill
 * @date 2019年4月28日
 */
class TreeNode {
    //数据项
    public long data;
    //数据项
    public String sdata;
    //左子节点
    public TreeNode leftChild;
    //右子节点

    public TreeNode rightChild;

    public TreeNode(long data, String sdata) {
        this.data = data;
        this.sdata = sdata;
    }

    public TreeNode(long data) {

        this.data = data;
    }

}

```

#### 二叉树的实现（迭代方式，使用栈）

##### C++

```c++
#include <iostream>
#include <stack>
using namespace std;
//使用模板
template<class Elem>
struct BinNode{
    Elem data;
    BinNode<Elem> *left;
    BinNode<Elem> *right;
    BinNode(Elem x){
    	data = x;
    	left=right=NULL;
    }
};
template<class Elem>
class BinTree{
protected:
    BinNode<Elem> *root;
    // 先序遍历(迭代)
    void ipreprint(BinNode<Elem> *r){
    	//需要使用栈来进行,目的记录是如何走的。把结点的指针压入栈
    	stack<BinNode<Elem>*> st;
    	if(r==NULL) return;
    	// 一直向左子树（访问压榨，向左，左为空弹栈，向右，回到根打印）
    	while(r){
    		cout << r->data << ' ';
    		st.push(r); // 压栈
    		r=r->left;
    		while(r== NULL && !st.empty() ){
    			// 左边空时
    			r=st.top(); // 记录栈顶元素
    			st.pop(); // 弹出栈
    			r=r->right;// 向右走一步
    		}
    	}
    }
    // 中序遍历(迭代)
    void iinprint(BinNode<Elem> *r){
    	//需要使用栈来进行,目的记录是如何走的。把结点的指针压入栈
    	stack<BinNode<Elem>*> st;
    	if(r==NULL) return;
    	while(r){
    		st.push(r); // 压栈
    		r=r->left;
    		while(r== NULL && !st.empty() ){
    			// 左边空时
    			r=st.top(); // 记录栈顶元素
    			st.pop(); // 弹出栈
    			cout << r->data << ' ';
    			r=r->right;// 向右走一步
    		}
    	}
    }
    // 后续遍历(迭代)
    void reafterprint(BinNode<Elem> *r){
    	//需要使用栈来进行,目的记录是如何走的。把结点的指针压入栈
    	stack<BinNode<Elem>*> st;
    	
    }
    //递归查找
    BinNode<Elem>* rfindX(Elem x ,BinNode<Elem> *root){
    	if(!root) return NULL;
		if(root->data == x) return root;
		BinNode<Elem> *found;
		found = rfindX(x,r->left);
		return found ? found : rfindx(x,x->right);
    }
    // 打印 以规定的形势
    void rprint(BinNode<Elem> *root,int depth){
    	
    	for(int i=0;i<depth;i++) cout << " ";
    	if(!root) {
    		cout<< "[/]" << endl;
    	}else{
    		cout << r->data<<endl;
    		rprint(r->left,depth+1);
    		rprint(r->right,depth+1);
    	}
    	
    }
public:
	BinNode(){ root = NULL;}
	// 构造函数
	BinTree(Elem r){
		root = new BinNode<Elem>(r);
	}
	// 析构函数
	~BinTree(){}
	// 先序遍历
	void ipreprint(){
		ipreprint(root);
		cout << endl;	
	}
	// 中序遍历
	void inprint(){
		reinprint(root);
	}
	// 后续遍历
	void reafterprint(){
		reafterprint(root);
	}
	// 查找元素返回结点的地址
	BinNode<Elem>* findX(Elem x){
		return rfindX(x,root)
	}
	// 插入
	bool insert(Elem parent,int leftOrRight,Elem x){
		BinNode<Elem> *found;
		found = findX(parent);
		// 如果found不为null
		if(!found) return false;
		if(leftOrRight == 0){
			if(found->left) return false;
			found->left = new BinNode<Elem>(x);
		}else{
			if(found->right) return false;
			found->right = new BinNode<Elem>(x);
		}
		return true;
	}
	// 打印
	void print(){
		rprint(root,0)
	}
};
int main(){
    BinTree<int> bt(11);
    // 插入结点 在结点为11的，0是左子树，插入元素22
    bt.insert(11,0,22);
    bt.insert(11,0,33);
    bt.insert(33,0,44);
     // 打印树先序
    bt.preprint();
    // 中序
    bt.inprint();
    // 后续
    bt.reafterprint();
    return 0;
}
```

#### 统计有无后代人的数量

[![srHM40.png](https://s3.ax1x.com/2021/01/17/srHM40.png)](https://s3.ax1x.com/2021/01/17/srHM40.png)

```c++
// 二叉树的先序中序后序实现

#include <iostream>
using namespace std;

template<class Elem>
struct BinNode{
    Elem data;
    BinNode<Elem>* left;
    BinNode<Elem>* right;
    BinNode(Elem x){
        data=x;
        left=right=NULL;
    }
};

template<class Elem>
class BinTree{
protected:
    BinNode<Elem>* root;
    // 先序遍历
    void rpreprint(BinNode<Elem>* r){   // 对于传指针，一定不要掉以轻心，要首先看一下指针是不是空指针
        if(r==NULL) return;
        cout<<r->data<<" ";
        rpreprint(r->left);
        rpreprint(r->right);
    }
    // 中序遍历
    void rinprint(BinNode<Elem>* r){
        if(r==NULL) return;
        rinprint(r->left);
        cout<<r->data<<" ";
        rinprint(r->right);
    }
    // 后续遍历
    void rpostprint(BinNode<Elem>* r){
        if(r==NULL) return;
        rinprint(r->left);
        rinprint(r->right);
        cout<<r->data<<" ";
    }
    // 数叶子结点
    int countLeaves(BinNode<Elem>* r){
        if(r==NULL) return 0;
        // 判断是不是只有一个根结点
        if(r->left==NULL && r->right==NULL) return 1;
        return countLeaves(r->left)+countLeaves(r->right);
    }
    // 查找结点
    BinNode<Elem>* rfindX(Elem x,BinNode<Elem>* r){
        if(!r)   return NULL;
        if(r->data==x)   return r;
        BinNode<Elem>* found;
        found=rfindX(x,r->left);
        return found?found:rfindX(x,r->right);
    }
    // 打印
    void rprint(BinNode<Elem>* r,int depth){
        for(int i=0;i<depth;i++)    cout<<"  ";
        if(!r){
            cout<<"[/]"<<endl;
        }
        else{
            cout<<r->data<<endl;
        rprint(r->left,depth+1);
        rprint(r->right,depth+1);
        }
    }

public:
    BinTree()   {root=NULL;}
    BinTree(Elem r){
        root=new BinNode<Elem>(r);
    }
    ~BinTree(){ };
    void preprint(){
        rpreprint(root);
        cout<<endl;
    }
    void inprint(){
        rinprint(root);
    }
    void postprint(){
        rpostprint(root);
    }
    void print(){
        rprint(root,0);
    }
    BinNode<Elem>* findX(Elem x){
        return rfindX(x,root);
    }
    bool insert(Elem p,int LorR,Elem x){
        BinNode<Elem>* found;
        found=findX(p);
        if(!found)  return false;
        if(LorR==0){
            if(found->left) return false;
            found->left=new BinNode<Elem>(x);
        }
        else{
            if(found->right)    return false;
            found->right=new BinNode<Elem>(x);
        }
        return true;
    }
    // 数叶子结点
    int count(){
        return countLeaves(root);
    }
};

int main(){
    string name;
    // 输入第一个name
    cin>>name;
    BinTree<string> bt(name);
    cin>>name;
    while(name!="-"){
        string  lc,rc;
        cin>>lc>>rc;
        if(lc!="-") bt.insert(name,0,lc);
        if(rc!="-") bt.insert(name,1,rc);
        cin>>name;
    }
    cout<<"叶子结点数目："<<bt.count()<<endl;
    return 0;
}
/*
Ann
Ann Bill Chris
Bill Daisy Ellen
Chric - Flin
Dasiy - -
Ellen Grace Henry
Flin - -
Grace - -
Henry - -
-
*/


```

#### 二叉搜索树(Binary Search Tree)

左子树元素比树根小

右子树元素比树根大

左右子树都是BST

##### BST查找

```c++
// 二叉树的头文件
#ifndef bintree_h
#define bintree_h


#include <iostream>
using namespace std;

template<class Elem>
struct BinNode{
    Elem data;
    int h;
    BinNode<Elem>* left;
    BinNode<Elem>* right;
    BinNode(Elem x){
        data=x;
        left=right=NULL;
    }
};

template<class Elem>
class BinTree{
protected:
    BinNode<Elem>* root;
    void rpreprint(BinNode<Elem>* r);
    void rinprint(BinNode<Elem>* r);
    void rpostprint(BinNode<Elem>* r);
    int cntLeaves(BinNode<Elem>* r);
    BinNode<Elem>* rfindX(Elem x,BinNode<Elem>* r);
    void rprint(BinNode<Elem>* r,int depth);
public:
    BinTree()   {root=NULL;}
    BinTree(Elem r){
        root=new BinNode<Elem>(r);
    }
    ~BinTree(){ };
    void preprint(){
        rpreprint(root);
        cout<<endl;
    }
    void inprint(){
        rinprint(root);
    }
    void postprint(){
        rpostprint(root);
    }
    void print(){
        rprint(root,0);
    }
    BinNode<Elem>* findX(Elem x){
        return rfindX(x,root);
    }
    bool insert(Elem p,int LorR,Elem x);
    int cnt(){
        return cntLeaves(root);
    }
};

template<class Elem>
void BinTree<Elem>::rpreprint(BinNode<Elem>* r){   // 对于传指针，一定不要掉以轻心，要首先看一下指针是不是空指针
        if(r==NULL) return;
        cout<<r->data<<" ";
        rpreprint(r->left);
        rpreprint(r->right);
    }

template<class Elem>
void BinTree<Elem>::rinprint(BinNode<Elem>* r){
        if(r==NULL) return;
        rinprint(r->left);
        cout<<r->data<<" ";
        rinprint(r->right);
    }

template<class Elem>
void BinTree<Elem>::rpostprint(BinNode<Elem>* r){
        if(r==NULL) return;
        rinprint(r->left);
        rinprint(r->right);
        cout<<r->data<<" ";
    }

template<class Elem>
int BinTree<Elem>::cntLeaves(BinNode<Elem>* r){
        if(r==NULL) return 0;
        if(r->left==NULL && r->right==NULL) return 1;
        return cntLeaves(r->left)+cntLeaves(r->right);
    }

template<class Elem>
BinNode<Elem>* BinTree<Elem>::rfindX(Elem x,BinNode<Elem>* r){
        if(!r)   return NULL;
        if(r->data==x)   return r;
        BinNode<Elem>* found;
        found=rfindX(x,r->left);
        return found?found:rfindX(x,r->right);
    }

template<class Elem>
void BinTree<Elem>::rprint(BinNode<Elem>* r,int depth){
        for(int i=0;i<depth;i++)    cout<<"  ";
        if(!r){
            cout<<"[/]"<<endl;
        }
        else{
            cout<<r->data<<endl;
        rprint(r->left,depth+1);
        rprint(r->right,depth+1);
        }
    }

template<class Elem>
bool BinTree<Elem>::insert(Elem p,int LorR,Elem x){
        BinNode<Elem>* found;
        found=findX(p);
        if(!found)  return false;
        if(LorR==0){
            if(found->left) return false;
            found->left=new BinNode<Elem>(x);
        }
        else{
            if(found->right)    return false;
            found->right=new BinNode<Elem>(x);
        }
        return true;
    }
#endif // bintree_h


```



```c++
// 二叉搜索树
#include <iostream>
#include "bintree.h"
using namespace std;
// 继承二叉树
template<class Elem>
class BSTree : public BinTree<Elem>{
protected:
	// 查找最大值（递归）
    BinNode<Elem>* rfindMax(BinNode<Elem>* r){
        if(r->right==NULL)  return r;
        return rfindMax(r->right);  // 尾递归
    }
    // 插入
    BinNode<Elem>* rinsert(Elem x,BinNode<Elem>* r){
        if(r==NULL){
            r=new BinNode<Elem>(x);
            if(!r)    throw -1;
        }
        // 如果x是比根结点的小，则向左侧进行插入
        else if(x<r->data)  r->left=rinsert(x,r->left);
        // 如果x是比根结点的大，则向右侧进行插入
        else if(x>r->data)  r->right=rinsert(x,r->right);
        else throw -2;
        return r;
    }
    // 删除（用左子树最大或右子树最小元素代替待删除的结点）
    // 删除左子树最大或者右子树最小
    BinNode<Elem>* rremove(Elem x,BinNode<Elem>* r){
        BinNode<Elem>* tmp;
        if(!r)  throw -1;
        else if(x<r->data){
            r->left=rremove(x,r->left);
        }else if(x>r->data){
            r->right=rremove(x,r->right);
        } else{
            if(r->left && r->right){
            	// 找左子树的最大
                tmp=rfindMax(r->left);
                r->data=tmp->data;
                r->left=rremove(tmp->data,r->left);
            }else{
                tmp=r;
                r=r->left?r->left:r->right;
                delete tmp;
            }
        }
        return r;
    }
public:
    BSTree(){
        this->root=NULL;
    }
    // 返回结点的地址
    BinNode<Elem>* findMax(){
    	// 递归的使用
    	//return rfindMax(this->root);
    	// 把递归改为使用循环（一路向右）因为 右子树元素比树根大
        BinNode<Elem>* tmp=this->root;
        while(tmp && tmp->right){
            tmp=tmp->right;
        }
        return tmp;
    }
    // // 返回结点的地址
    BinNode<Elem>* findMin(){
       // 使用循环（一路向左）因为 左子树元素比树根小
        BinNode<Elem>* tmp=this->root;
        while(tmp && tmp->left){
            tmp=tmp->left;
        }
        return tmp;
    }
    // 查找元素并返回结点的地址
    BinNode<Elem>* findX(Elem x){
    	// 查找是根节点
        BinNode<Elem>* tmp=this->root;
        // x不是根结点时，
        while(tmp && x!=tmp->data){
        	// 如果x小于根结点，则一直向左
            if(x<tmp->data) tmp=tmp->left;
            // 如果x大于根结点，则一直向左
            else    tmp=tmp->right;
        }
        return tmp;
    }
    // 插入
    bool insert(Elem x){
        try{
            this->root=rinsert(x,this->root);
        }catch(int e){
            return false;
        }
        return true;
    }
    // 删除
    bool remove(Elem x){
        try{
            this->root=rremove(x,this->root);
        }catch(int e){
            return false;
        }
        return true;
    }
};
int main(){
    BSTree<int> bt;
    bt.insert(10);
    bt.insert(5);
    bt.insert(20);
    bt.insert(8);
    bt.insert(15);
    bt.insert(2);
    bt.insert(6);
    bt.print();
    cout<<"---------"<<endl;
    bt.remove(10);
    bt.print();
    return 0;
}
```

#### 平衡二叉树（AVL树）

空树是平衡的，

##### 插入

RR单旋 ：与LL单旋对称。

RL双旋：与LR双旋对称。

```c++
// 二叉搜索树
#ifndef bstree_h
#define bstree_h

#include <iostream>
#include "bintree.h"
using namespace std;
// 继承二叉树
template<class Elem>
class BSTree : public BinTree<Elem>{
protected:
	// 查找最大值（递归）
    BinNode<Elem>* rfindMax(BinNode<Elem>* r){
        if(r->right==NULL)  return r;
        return rfindMax(r->right);  // 尾递归
    }
    // 插入
    BinNode<Elem>* rinsert(Elem x,BinNode<Elem>* r){
        if(r==NULL){
            r=new BinNode<Elem>(x);
            if(!r)    throw -1;
        }
        // 如果x是比根结点的小，则向左侧进行插入
        else if(x<r->data)  r->left=rinsert(x,r->left);
        // 如果x是比根结点的大，则向右侧进行插入
        else if(x>r->data)  r->right=rinsert(x,r->right);
        else throw -2;
        return r;
    }
    // 删除（用左子树最大或右子树最小元素代替待删除的结点）
    // 删除左子树最大或者右子树最小
    BinNode<Elem>* rremove(Elem x,BinNode<Elem>* r){
        BinNode<Elem>* tmp;
        if(!r)  throw -1;
        else if(x<r->data){
            r->left=rremove(x,r->left);
        }else if(x>r->data){
            r->right=rremove(x,r->right);
        } else{
            if(r->left && r->right){
            	// 找左子树的最大
                tmp=rfindMax(r->left);
                r->data=tmp->data;
                r->left=rremove(tmp->data,r->left);
            }else{
                tmp=r;
                r=r->left?r->left:r->right;
                delete tmp;
            }
        }
        return r;
    }
public:
    BSTree(){
        this->root=NULL;
    }
    // 返回结点的地址
    BinNode<Elem>* findMax(){
    	// 递归的使用
    	//return rfindMax(this->root);
    	// 把递归改为使用循环（一路向右）因为 右子树元素比树根大
        BinNode<Elem>* tmp=this->root;
        while(tmp && tmp->right){
            tmp=tmp->right;
        }
        return tmp;
    }
    // // 返回结点的地址
    BinNode<Elem>* findMin(){
       // 使用循环（一路向左）因为 左子树元素比树根小
        BinNode<Elem>* tmp=this->root;
        while(tmp && tmp->left){
            tmp=tmp->left;
        }
        return tmp;
    }
    // 查找元素并返回结点的地址
    BinNode<Elem>* findX(Elem x){
    	// 查找是根节点
        BinNode<Elem>* tmp=this->root;
        // x不是根结点时，
        while(tmp && x!=tmp->data){
        	// 如果x小于根结点，则一直向左
            if(x<tmp->data) tmp=tmp->left;
            // 如果x大于根结点，则一直向左
            else    tmp=tmp->right;
        }
        return tmp;
    }
    // 插入
    bool insert(Elem x){
        try{
            this->root=rinsert(x,this->root);
        }catch(int e){
            return false;
        }
        return true;
    }
    // 删除
    bool remove(Elem x){
        try{
            this->root=rremove(x,this->root);
        }catch(int e){
            return false;
        }
        return true;
    }
};
```

```c++
// 平衡二叉树是一个二叉搜索树的子类
#include <iostream>
#include "bstree.h"
using namespace std;
template<class Elem>
// 在BinNode的类中加入high 属性
class AVLTree:public BsTree<ELem>{
protected:
	int height(BinNode<Elem>* r){
		if(!r) return -1;
		return r->h;
	}
	// 给定一个结点进行左左旋转
	BinNode<Elem>* LLrotate(BinNode<Elem>* r){
		BinNode<Elem> *child;
		child = r->left;
		r->left = child->right;
		child->right = r;
		r->h = max(height(r->left),height(r->right))+1;
		child->h = max(height(child->left),height(child->right))+1;
		return child;
	}
	// 给定一个结点进行右右旋转
	BinNode<Elem>* RRrotate(BinNode<Elem>* r){
		BinNode<Elem> *child;
		child = r->right;
		r->right = child->left;
		child->left = r;
		r->h = max(height(r->left),height(r->right))+1;
		child->h = max(height(child->left),height(child->right))+1;
		return child;
	}
	// 给定一个结点进行左右旋转
	BinNode<Elem>* LRrotate(BinNode<Elem>* r){
		r->left = RRrotate(r->left);
		return LLrotate(r);
	}
	// 给定一个结点进行右左旋转
	BinNode<Elem>* RLrotate(BinNode<Elem>* r){
		r->right = LLrotate(r->left);
		return  RRrotate(r);
	}
	// 插入
    BinNode<Elem>* rinsert(Elem x,BinNode<Elem>* r){
        if(r==NULL){
            r=new BinNode<Elem>(x);
            if(!r)    throw -1;
        }
        // 如果x是比根结点的小，则向左侧进行插入
        else if(x<r->data){
        	r->left=rinsert(x,r->left);
        	// 判断是否平衡
        	if(height(r->left)-height(r->right) == 2){
        		if(x<r->left->data){
        			r=LLrotate(r);
        		}else{
        			r=LRrotate(r);
        		}
        	}else if(x>r->data){
        		r->right = rinsert(x,r->right);
        		if(height(r->right)-height(r->left) == 2){
        			r=RRrotate(r);
        		}else{
        			r=RLrotate(r);
        		}
        	}else{ throw -2}
        	r->h = max(height(r->left),height(r->right))+1;
        	return r;
        }  
        // 如果x是比根结点的大，则向右侧进行插入
        else if(x>r->data){
         	r->right=rinsert(x,r->right);
        } 
        else throw -2;
        return r;
    }
    
public:
	AVLTree(){
		this->root = NULL;
	}
}
int main(){
	AVLTree<int> t;
	t.insert(30);
	t.insert(20);
	t.print();
	cout << "----" << endl;
	t.insert(10);
	t.print();
	return 0;
}
```

### 优先队列与集合

#### 优先队列

#### 集合

#### 不相交集



### 查找与散列

#### 散列

目标 ：为了更快的查找 ---O(1),拿空间换时间， 计算空间位置更快

##### 定义

“键 -值 对” （key- value pair）的集合

**两个关键的问题**

- 散列函数 什么是好的散列函数

- 解决冲突 如何进行解决冲突

##### 解决冲突方式

- 开放定址

- 分离链

- 其他（公共溢出）

**开放定址**

h(x) = x mod 11

x={12,2,17,28,6,23} h(x) = {1,2,6,6,1}

这样以来就有冲突了，这个当冲突时则可以将数据进行往后的坐标点放入  可进行 线性探测，平方探测。。。

**分离链**

h(x) = x mod 11

x={12,2,17,28,6,23} h(x) = {1,2,6,6,1}

是在这个结点做个链表结点 。单链表的插入删除

##### **C实现**

```c
// 开放定址法，删除时时不能真正的删，只能逻辑的删除，让其标记
#include <stdio.h>
#include <stdio.h>
// 标记的状态
enum GridStatus{Active,Removed,Empty};
typedef enum GridStatus Status;
struct HashTable{
    int *key; // key
    Status *status; // 标记的状体
    int size; // 表里的大小
    int remains; // 表中剩余的大小
};
typedef struct HashTable *HT;
HT initHashTable(int size){
    HT h;
    h= (HT) malloc(sizeof(struct HashTable));
    if(!h) return NULL;
    h->size = h->remains =size;
    h->key = (int *)malloc(sizeof(Status)* size);
    if(!h->status){ free(h->key);free(h); return NUll;}
    for(int i=0;i<size;i++){
        h->status[i]=Empty;
    }
    return h;
}
// hash函数
int hash(int x,int p){
    return x%p;
}
int isFull(const HT h){
    return h->remains == 0;
}
// 插入
int insertX(int x, HT h){
    if(isFull(h)) return 0;
    int pos=hash(x,h->size);
    while(h->status[pos] == Active){
        pos = (pos+1) % h -> size;
    }
    h->key[pos] = x;
    h->status[pos] =Active;
    h->remains--;
    return 1;
}
// 查找
int findX(int x,HT h){
  int pos,index;
  index=pos= hash(x,h->size);
  while(h-status[pos]!=Empty){
      if(h->key[pos] == x && h-status[pos] == Active) return pos;
      pos= (pos+1)% h->size; // 循环一圈
      if(pos == index) break;
      return -1;
  }
}
//remove
int removeX(int x, HT h){
    int pos = findX(x,h);
    if(pos==-1) return 0;
    // 只做标记，不修改其中的值，这是绝大部分就是这样的。
    h->status[pos] = Empty; 
}
void printHT(const HT h){
    for(int i=0;i<h-size;i++){
        printf("%4d",i){
    }
    putchar('\n');
    for(int i=0;i<h-size;i++){
        if(h->status[i] == Active) printf("%4d",h->key[i]);
        else if(h->status[i]==Removed) printf("   X");
        else printf("   -");
    }
    putchar('\n');
}
int main(){
    HT h=initHashTable(11);
    insertX(5,h);
    return 0;
}
```

##### C++

```c++
#include <iostream>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
using namespace std;
int main() {
    unordered_set<int> s;
    unordered_map<int, int> m;
    m[101] =33;
    m[-10] = 2233;
    m.inser(pair<int,int>(22,33));
    return 0;
}
```

##### Java

```
Map-->HashMap; 键值对映射
Set--->HashSet;

```

JAVA中的hashmap是在jdk1.8以前时采用的时数组+链表，jdk1.8以后采用的是数组+链表+红黑树，当元素的个数在8时将链表转为红黑树，所以hashmap的元素的个数在8左右时会将消耗性能。hashMap的初始值元素的个数为16，hashMap的自增因子为0.75，当元素个数为32的时候初始容量为  32/0.75= 。  

##### Python

```python
d = dict() # 字典
d[100] =50

```

### 排序

#### 简单选择排序

每次从未排序的元素中选择最大（小）的放入排序序列 O(n^2)

##### C语言

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *p1,int *p2){
    int t;
    t = *p1;
    *p1 = *p2;
    *p2 = t;
}
void printArray(const int *array,int size){
    for(int i=0;i<size;i++){
        printf("%d ",array[i]);
    }
    putchar('\n');
}
void selectionSort(int *array,int size){
    int minv,min;
    for(int i=0;i<size-1;i++){
        minv = array[i];
        min = i;
        for(int j=i+1;j<size;j++){
            if(array[j]<minv){
                minv = array[j];
                min = j;
            }
        }
     	if(min - i) swap(&array[i],&array[min]);
        printf("%d: ",i);
        printArray(array,size);
    }
}
int main(){
    int array[6]={19,54,4,30,70,2};
    selectionSort(array,6);
    return 0;
}
```

#### 简单插入排序

每次把未排序的元素中的第一个元素插入到一已排序的序列中。最坏和平均都是O(n^2)

##### C语言

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *p1,int *p2){
    int t;
    t = *p1;
    *p1 = *p2;
    *p2 = t;
}
void printArray(const int *array,int size){
    for(int i=0;i<size;i++){
        printf("%d ",array[i]);
    }
    putchar('\n');
}
void insertionSort(int *array,int size){
    // 把一个固定，把当前元素依次和前面的比较
    // 
    int x;
    for(int i=1,j;i<size;i++){
        x=array[i]; // 把
        for(j=i; j>0 && array[j-1]>x;j--){
            array[j]=array[j-1];
        }
        array[j]=x;
        printf("%d: ",i);
        printArray(array,size);
    }
}
int main(){
    int array[6]={19,54,4,30,70,2};
    insertionSort(array,6);
    return 0;
}
```

#### 冒泡排序

从开始到序列结束两两进行比较，逆序则交换，到序列结束，谓之一趟排序。复杂度 O(n^2)  稳定

##### C语言

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *p1,int *p2){
    int t;
    t = *p1;
    *p1 = *p2;
    *p2 = t;
}
void printArray(const int *array,int size){
    for(int i=0;i<size;i++){
        printf("%d ",array[i]);
    }
    putchar('\n');
}
void bubbleSort(int *array,int size){
    int flag=1; // 是否进行交换。
    for(int i=0;flag && i<size;i++){
        for(int j=0;j<size-1-i;j++){
            if(array[j]> array[j+1]){  
                swap(&array[j],&array[j+1]);
                flag=1;
            }
        }
        printf("%d",i);
        printArray(array,size);
    }
}
int main(){
    int array[6]={19,54,4,30,70,2};
    bubbleSort(array,6);
    return 0;
}
```

#### 希尔排序（Shell Sort）

变步长的插入排序，效率与步长序列选取有关，争取选用奇数步长，比如 5-sort,3-sort,1-sort

#### 堆排序

优先队列（堆）删除堆顶：O(log N)

按序出队

连续删除N次堆顶 => 排序

时间负杂度： O(N log N)

额外空间负杂度： O(N)

##### C语言

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *p1,int *p2){
    int t;
    t = *p1;
    *p1 = *p2;
    *p2 = t;
}
void printArray(const int *array,int size){
    for(int i=0;i<size;i++){
        printf("%d ",array[i]);
    }
    putchar('\n');
}
// 向下过滤
void percolateDown(int k,int *array,int size){
    int x;
    x=array[k];
    int i,child;
    for(i=k;i*2+1 <size;i=child){
        child = i*2+1;
        // 大顶堆
        if(child!=size-1 && array[child+1] >array[child]){
            child++;
        }
        if(x < array[child]){
            array[i] = array[child];
        }else{break;}    
    }
    array[i]=x;
}
void heapSort(int *array,int size){
   // 完全二叉树，删堆顶就是把元素给交换一下。
   // 创建堆 size/2-1时父亲结点,从最后一个有儿子的结点向下过滤
    for(int i=size/2-1;i>=0;i--){
       percolateDown(i,array,size);
   } 
    for(int i=size-1;i>0;i--){
        swap(&array[0],&array[i]);
        percolateDown(0,array,i);
    }
}
int main(){
    int array[6]={19,54,4,30,70,2};
    heapSort(array,6);
    return 0;
}
```

#### 分治法

分治法:分而治之，

可行性：

- 大规模的问题能分解成若干小规模问题

- 小规模问题求解后，不难合并求大规模问题的解。

- 小规模问题求解可能比大规模问题简单

有意义：

- 大规模问题求解负杂度> O(N)

  N/2+N/2 = N    (N/2)^2 +(N/2)^2 < N^2

#### 归并排序

（分治法）

##### C语言

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *p1,int *p2){
    int t;
    t = *p1;
    *p1 = *p2;
    *p2 = t;
}
void printArray(const int *array,int size){
    for(int i=0;i<size;i++){
        printf("%d ",array[i]);
    }
    putchar('\n');
}
void msort(int *array,int *tmp,int left,int right){
    if(left>=right) return;
    int mid;
    mid = (left+right)/2;
    msort(array,tmp,left,mid);
    msort(array,tmp,mid+1,right);
    merge(array,tmp,left,mid+1,right);
}
void merge(int *a,int *t,int li,int ri,int re){
    int le,ti,begin;
    le = ri-1;
    begin=ti = li;
    while(li<=le && ri<=re){
        if(a[li]<=a[ri]) t[ti++] = a[li++];
        else t[ti++] = a[ri++]
    }
    while(li<=le) t[ti++] = a[li++];
    while(ri<=re) t[ti++] = a[ri++];
    for(int i=begin;i<=re;i++) a[i]=t[i];
}
void mergeSort(int *array,int size){
  int *tmp;
  tmp = (int*)malloc(sizeof(int) * size);
  if(!tmp) return;
  msort(array,tmp,0,size-1);
  free(tmp);
}
int main(){
    int array[6]={19,54,4,30,70,2};
    mergeSort(array,6);
    return 0;
}
```

#### 快速排序

分类思想。分割的点要选择好，   （分治法）

一般取中位数，不一定很好但一定不最差。

##### C语言

```c
#include <stdio.h>
#include <stdlib.h>
void swap(int *p1,int *p2){
    int t;
    t = *p1;
    *p1 = *p2;
    *p2 = t;
}
void printArray(const int *array,int size){
    for(int i=0;i<size;i++){
        printf("%d ",array[i]);
    }
    putchar('\n');
}
int medianPivot(int *a,int left,int right){
    int mid = (left+right)/2;
    if(a[left]>a[mid]) swap(&a[left],&a[mid]);
    if(a[left]>a[right]) swap(&a[left],&a[right]);
    if(a[mid]>a[right]) swap(&a[mid],&a[right]);
    swap(&a[mid],&a[right-1]);
    return a[right-1];
}
// 低于20个插入排序，高于20个快排
const int cutoff=20;

void insertionSort(int *array,int size){
    // 把一个固定，把当前元素依次和前面的比较
    // 
    int x;
    for(int i=1,j;i<size;i++){
        x=array[i]; // 把
        for(j=i; j>0 && array[j-1]>x;j--){
            array[j]=array[j-1];
        }
        array[j]=x;
        printf("%d: ",i);
        printArray(array,size);
    }
}
void qSort(int *array,int left,int right){
    int pivort;
    if(right-left <cutoff){
        insertionSort(a+left,right-left+1);
    }else{
        // 选择一个中位数
   	    pivot=medianPivot(a,left,right); 
        int i,j;
        i=left+1;
        j=right-2;
        while(1){
            while(a[i]<pivot) i++; // i从左
            while(a[j]<pivot) j--; // j从右
            if(i<j) swap(&a[i],&a[j]);
            else break;
        }
        swap(&a[i],&a[right-1]);
        qSort(a,left,i-1);
        qSort(a,i+1,right);
    } 
  
}
void quickSort(int *array,int size){
 	// 内部递归
    qSort(array,0,size-1);
}
int main(){
    int array[6]={19,54,4,30,70,2};
    quickSort(array,6);
    return 0;
}
```

#### 桶排序

输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入[元素分配](https://baike.baidu.com/item/元素分配)到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] <1辅助[数组](https://baike.baidu.com/item/数组)B[0..n-1]是一[指针数组](https://baike.baidu.com/item/指针数组)，指向桶（[链表](https://baike.baidu.com/item/链表)）

#### 基数排序

### 图

#### 概念

有向图/无向图

#### 图的表示

##### 邻接矩阵

在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。

[![6pAa5D.png](https://s3.ax1x.com/2021/02/27/6pAa5D.png)](https://imgtu.com/i/6pAa5D)

##### 邻接表

在邻接列表实现中，每一个顶点会存储一个从它这里开始的边的列表。比如，如果顶点A 有一条边到B、C和D，那么A的列表中会有3条边



![img](https://upload-images.jianshu.io/upload_images/4064751-38001183923906c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/795/format/webp)

邻接列表只描述了指向外部的边。A 有一条边到B，但是B没有边到A，所以 A没有出现在B的邻接列表中。查找两个顶点之间的边或者权重会比较费时，因为遍历邻接列表直到找到为止。

#### 图的遍历

图的遍历指的是从任意一个顶点的出发沿着边 访问所有顶点的过程。使得每个顶点只访问一次。

遍历方式分为 ：DFS(深度优先搜索),BFS(广度优先搜索)

##### 深度优先搜索

**算法思想**

假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止

**算法特点**

深度优先搜索是一个递归的过程。首先，选定一个出发点后进行遍历，如果有邻接的未被访问过的节点则继续前进。若不能继续前进，则回退一步再前进，若回退一步仍然不能前进，则连续回退至可以前进的位置为止。重复此过程，直到所有与选定点相通的所有顶点都被遍历。

深度优先搜索是递归过程，带有回退操作，因此需要使用栈存储访问的路径信息。当访问到的当前顶点没有可以前进的邻接顶点时，需要进行出栈操作，将当前位置回退至出栈元素位置

[具体细节查看](https://blog.csdn.net/yue_2018/article/details/89060556)

##### 广度优先搜索

**广度优先搜索思想：**从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

**算法特点**

广度优先搜索类似于树的层次遍历，是按照一种由近及远的方式访问图的顶点。在进行广度优先搜索时需要使用队列存储顶点信息



#### 拓扑排序

#### 最短路径

#### 最小生成树

