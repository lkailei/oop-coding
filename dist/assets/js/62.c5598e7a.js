(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{455:function(v,_,s){"use strict";s.r(_);var e=s(31),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h3",{attrs:{id:"_2019-06-17-乐精灵"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-17-乐精灵"}},[v._v("#")]),v._v(" 2019-06-17 乐精灵")]),v._v(" "),s("p",[s("strong",[v._v("1.你了解nginx吗说下nginx的负载均衡策略")])]),v._v(" "),s("p",[v._v("Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。Nginx既可以在内部的直接支持Rails和PHP程序对外进行服务,也可以支持HTTP代理服务对外进行服务，采用C语言编写,处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。无缓存的反向代理加速，简单的负载均衡和容错。FastCGI，简单的负载均衡和容错。模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCG或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。支持 SSL 和 TLSSNI。")]),v._v(" "),s("p",[s("strong",[v._v("应用它可以干什么：")])]),v._v(" "),s("ol",[s("li",[v._v("http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。")]),v._v(" "),s("li",[v._v("虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。")]),v._v(" "),s("li",[v._v("反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况")])]),v._v(" "),s("p",[s("strong",[v._v("主要算法策略：")])]),v._v(" "),s("ol",[s("li",[s("strong",[v._v("weight轮训（默认）")]),v._v("：接收到的请求按照顺序逐一分配到不同的后端服务器，如果某个服务器拓机的情况下，nginx会将其剔除队列，请求受理情况不会受到影响，可以给不同的后端服务配置权重值，用于调整不同的服务器上请求的分配率，权重越大被分配到的请求的几率越大。")]),v._v(" "),s("li",[s("strong",[v._v("ip_hash :")]),v._v(" 每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题")]),v._v(" "),s("li",[s("strong",[v._v("fair")]),v._v("：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块")]),v._v(" "),s("li",[s("strong",[v._v("url_hash")]),v._v("：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包")])]),v._v(" "),s("p",[s("strong",[v._v("2.消息队列用过吗，ActiveMQ用过吗？")])]),v._v(" "),s("p",[v._v("ActiveMQ是Apache出品，流行开源的消息总线，ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,")]),v._v(" "),s("p",[s("strong",[v._v("消息类型:")])]),v._v(" "),s("p",[v._v("一种是点对点的，即一个生产者和一个消费者一一对应；")]),v._v(" "),s("p",[v._v("另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。")]),v._v(" "),s("p",[s("strong",[v._v("使用：")])]),v._v(" "),s("p",[v._v("producer----\x3etopic---\x3econsumer：")]),v._v(" "),s("ol",[s("li",[v._v("每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费")]),v._v(" "),s("li",[v._v("发布者和订阅者之间有时间上的依赖性。")]),v._v(" "),s("li",[v._v("针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。")]),v._v(" "),s("li",[v._v("为了消费消息，订阅者必须保持运行的状态。")])]),v._v(" "),s("p",[v._v("producer----\x3eQueue---\x3econsumer：")]),v._v(" "),s("ol",[s("li",[v._v("每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)")]),v._v(" "),s("li",[v._v("发送者和接收者之间在时间上没有依赖性")]),v._v(" "),s("li",[v._v("接收者在成功接收消息之后需向队列应答成功")])]),v._v(" "),s("p",[s("strong",[v._v("3.vue.js，以及哪些前端ui")])]),v._v(" "),s("p",[s("strong",[v._v("4.如何保证线程安全")])]),v._v(" "),s("p",[v._v("基本上所有的并发模式在解决线程安全问题上，都采用“序列化访问临界资源”的方案，即在同一时刻，只能有一个线程访问临界资源，也称同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。在Java中，提供了两种方式来实现同步互斥访问：synchronized和Lock。")]),v._v(" "),s("p",[s("strong",[v._v("5.liunx的命令")])]),v._v(" "),s("p",[s("strong",[v._v("6.hashset与hashtable的区别")])]),v._v(" "),s("p",[v._v("两者都是key-value形式的。hashset线程不安全的，hashtable线程安全。")]),v._v(" "),s("p",[s("strong",[v._v("7.ArrayList和linkedList的区别")])]),v._v(" "),s("p",[v._v("两个都是list接口，arrylist是基于索引的底层是数组，可以以O(1)的时间随机访问，")]),v._v(" "),s("p",[v._v("linkedlist：是以元素列表形式存储的，linkedlist的插入，添加，删除操作速度更快，因为他不需要计算索引了 linkedlist比arraylist更占内存。")]),v._v(" "),s("p",[s("strong",[v._v("8.Myssql分库分表用过吗？什么可以作为索引")])]),v._v(" "),s("p",[s("strong",[v._v("为什么要分表：")])]),v._v(" "),s("p",[v._v("当一张表的数据达到几千万时，你查询一次所花的时间会变多，如果有联合查询的话，我想有可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。")]),v._v(" "),s("p",[v._v("mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。")]),v._v(" "),s("p",[s("strong",[v._v("分库分表的规则：")])]),v._v(" "),s("ol",[s("li",[s("p",[v._v("单库单表")]),v._v(" "),s("blockquote",[s("p",[v._v("单库单表是最常见的数据库设计，例如，有一张用户(user)表放在数据库db中，所有的用户都可以在db库中的user表中查到。")])])]),v._v(" "),s("li",[s("p",[v._v("单库多表")]),v._v(" "),s("blockquote",[s("p",[v._v("随着用户数量的增加，user表的数据量会越来越大，当数据量达到一定程度的时候对user表的查询会渐渐的变慢，从而影响整个DB的性能。如果使用mysql, 还有一个更严重的问题是，当需要添加一列的时候，mysql会锁表，期间所有的读写操作只能等待。 可以通过某种方式将user进行水平的切分，产生两个表结构完全一样的user_0000,user_0001等表，user_0000 + user_0001 + …的数据刚好是一份完整的数据。")])])]),v._v(" "),s("li",[s("p",[v._v("多库多表")]),v._v(" "),s("blockquote",[s("p",[v._v("随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候可以再对数据库进行水平区分。")])])])]),v._v(" "),s("p",[s("strong",[v._v("分库分表的出现的问题：")])]),v._v(" "),s("ol",[s("li",[s("p",[v._v("分库分表维度的问题")]),v._v(" "),s("blockquote",[s("p",[v._v("假如用户购买了商品,需要将交易记录保存取来，如果按照用户的纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的 购买情况，但是某商品被购买的情况则很有可能分布在多张表中，查找起来比较麻烦。反之，按照商品维度分表，可以很方便的查找到此商品的购买情况，但要查找 到买人的交易记录比较麻烦。")])])]),v._v(" "),s("li",[s("p",[v._v("联合查询的问题")])])]),v._v(" "),s("blockquote",[s("p",[v._v("联合查询基本不可能，因为关联的表有可能不在同一数据库中。")])]),v._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[s("p",[v._v("尽量把同一组数据放到同一DB服务器上")]),v._v(" "),s("blockquote",[s("p",[v._v("例如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。也就是说避免数据库中的数据依赖另一数据库中的数据。")])])]),v._v(" "),s("li",[s("p",[v._v("一主多备")]),v._v(" "),s("blockquote",[s("p",[v._v("在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.")])]),v._v(" "),s("blockquote",[s("p",[v._v("所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。")]),v._v(" "),s("p",[v._v("所以当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。当写压力很大的时候，就必须得进行分库操作。")])])])]),v._v(" "),s("p",[s("strong",[v._v("什么可以作为索引")])]),v._v(" "),s("p",[v._v("索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。")]),v._v(" "),s("ol",[s("li",[s("p",[v._v("对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引")])]),v._v(" "),s("li",[s("p",[v._v("数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。")])]),v._v(" "),s("li",[s("p",[v._v('在一同值少的列上(字段上)不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。')]),v._v(" "),s("p",[v._v("注：今后要把这个索引给实现了。")])])]),v._v(" "),s("p",[s("strong",[v._v("9.介绍一下dubbo")])]),v._v(" "),s("p",[v._v("Dubbo是  阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和  Spring框架无缝集成。")]),v._v(" "),s("p",[v._v("Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。为了实现不同系统之间的通信")]),v._v(" "),s("p",[s("strong",[v._v("主要核心部件：")])]),v._v(" "),s("ul",[s("li",[v._v("Remoting:网路通讯框架，实现了sync-over-async和request-response消息机制")]),v._v(" "),s("li",[v._v("RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能")]),v._v(" "),s("li",[v._v("Registry: 服务目录框架用于服务的注册和服务事件发布和订阅")])]),v._v(" "),s("p",[v._v("Dubbo就是资源调度和治理中心的管理工具。")]),v._v(" "),s("p",[s("strong",[v._v("10.redis介绍一下")])]),v._v(" "),s("p",[v._v("Redis是一个高性能的key-value的数据库，支持数据的持久化，提供不同类型的数据结构存储，支持数据备份。")]),v._v(" "),s("p",[v._v("Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。")]),v._v(" "),s("p",[v._v("Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。 在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。")]),v._v(" "),s("p",[s("strong",[v._v("数据类型：")])]),v._v(" "),s("blockquote",[s("p",[v._v("字符型，散列型，列表型list，集合型set，有序集合型sort set。")])]),v._v(" "),s("p",[s("strong",[v._v("使用目的")])]),v._v(" "),s("p",[v._v("配合关系型数据库做高速缓存，持久化特定数据，减轻访问数据库的压力，获得更高的并发和更快捷的请求响应速度。")]),v._v(" "),s("p",[s("strong",[v._v("持久化方式RDB和AOF")])]),v._v(" "),s("p",[v._v("RDB：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案。")]),v._v(" "),s("p",[v._v("AOF:以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程 （主流方式：具有实时性）")]),v._v(" "),s("p",[s("strong",[v._v("如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。")])]),v._v(" "),s("p",[s("strong",[v._v("有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。")])]),v._v(" "),s("ul",[s("li",[v._v("RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊")]),v._v(" "),s("li",[v._v("如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF")]),v._v(" "),s("li",[v._v("如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB")]),v._v(" "),s("li",[v._v("灾难恢复选用RDB")]),v._v(" "),s("li",[v._v("双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量")])])])}),[],!1,null,null,null);_.default=t.exports}}]);