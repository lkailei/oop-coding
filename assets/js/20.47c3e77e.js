(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{413:function(t,r,e){"use strict";e.r(r);var a=e(31),_=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"java并发编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java并发编程"}},[t._v("#")]),t._v(" Java并发编程")]),t._v(" "),e("h2",{attrs:{id:"进程与线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[t._v("#")]),t._v(" 进程与线程")]),t._v(" "),e("h3",{attrs:{id:"什么是进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是进程"}},[t._v("#")]),t._v(" 什么是进程")]),t._v(" "),e("p",[t._v("进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("操作系统"),e("OutboundLink")],1),t._v("结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。"),e("strong",[t._v("程序执行的最小单位")])]),t._v(" "),e("h4",{attrs:{id:"进程的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程的特点"}},[t._v("#")]),t._v(" 进程的特点")]),t._v(" "),e("p",[t._v("动态性：进程的实质是程序在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("多道程序系统"),e("OutboundLink")],1),t._v("中的一次执行过程，进程是动态产生，动态消亡的。")]),t._v(" "),e("p",[t._v("并发性：任何进程都可以同其他进程一起并发执行")]),t._v(" "),e("p",[t._v("独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[t._v("异步性"),e("OutboundLink")],1),t._v("：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进")]),t._v(" "),e("p",[t._v("结构特征：进程由程序、数据和"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97",target:"_blank",rel:"noopener noreferrer"}},[t._v("进程控制块"),e("OutboundLink")],1),t._v("三部分组成。")]),t._v(" "),e("p",[t._v("多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。")]),t._v(" "),e("h3",{attrs:{id:"什么是线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程"}},[t._v("#")]),t._v(" 什么是线程")]),t._v(" "),e("p",[e("strong",[t._v("线程")]),t._v("（英语：thread）是"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("操作系统"),e("OutboundLink")],1),t._v("能够进行运算"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6",target:"_blank",rel:"noopener noreferrer"}},[t._v("调度"),e("OutboundLink")],1),t._v("的最小单位。它被包含在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("进程"),e("OutboundLink")],1),t._v("之中，是"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("进程"),e("OutboundLink")],1),t._v("中的实际运作单位。一条线程指的是"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("进程"),e("OutboundLink")],1),t._v("中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及"),e("a",{attrs:{href:"https://baike.baidu.com/item/SunOS",target:"_blank",rel:"noopener noreferrer"}},[t._v("SunOS"),e("OutboundLink")],1),t._v("中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。"),e("strong",[t._v("程序执行的最小单位")])]),t._v(" "),e("h4",{attrs:{id:"线程的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程的特点"}},[t._v("#")]),t._v(" 线程的特点")]),t._v(" "),e("p",[e("strong",[t._v("1.轻型实体")])]),t._v(" "),e("blockquote",[e("p",[t._v("线程中的实体单位基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。")])]),t._v(" "),e("p",[t._v("​    线程的实体包括程序、数据和TCB。线程是动态概念，他的动态特性由线程控制块TCB描述。TCB包括以下信息：")]),t._v(" "),e("blockquote",[e("p",[t._v("1）线程状态。")]),t._v(" "),e("p",[t._v("2）当线程不运行时，被保存的现场资源。")]),t._v(" "),e("p",[t._v("3）一组执行堆栈。")]),t._v(" "),e("p",[t._v("4）存放每个线程的局部变量主存区。")]),t._v(" "),e("p",[t._v("5）访问同一个进程中的主寸和其他资源。")])]),t._v(" "),e("p",[t._v("​    用于被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。")]),t._v(" "),e("p",[e("strong",[t._v("2.独立调度和分派的基本单位")])]),t._v(" "),e("blockquote",[e("p",[t._v("再多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。但由于线程很“轻”，故线程的切换非常迅速且开销小（在统一进程中的）。")])]),t._v(" "),e("p",[e("strong",[t._v("3.可并发执行")])]),t._v(" "),e("blockquote",[e("p",[t._v("在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。")])]),t._v(" "),e("p",[e("strong",[t._v("4.共享进程资源")])]),t._v(" "),e("blockquote",[e("p",[t._v("在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味者，线程可以访问该地址空间的每一个虚地址；此外，还可以访问该进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。")])]),t._v(" "),e("p",[t._v("涞源：维基百科")]),t._v(" "),e("h3",{attrs:{id:"进程与线程的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程的区别"}},[t._v("#")]),t._v(" 进程与线程的区别")]),t._v(" "),e("p",[t._v("线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。因为多个线程共享父进程里的全部资源，因此编程更加方便；但必须更加小心，我们必须确保线程不会妨碍同一进程里的其他线程。")]),t._v(" "),e("p",[t._v("Ⅰ 拥有资源")]),t._v(" "),e("p",[t._v("进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。")]),t._v(" "),e("p",[t._v("Ⅱ 调度")]),t._v(" "),e("p",[t._v("线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。")]),t._v(" "),e("p",[t._v("Ⅲ 系统开销")]),t._v(" "),e("p",[t._v("由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。")]),t._v(" "),e("p",[t._v("Ⅳ 通信方面")]),t._v(" "),e("p",[t._v("线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。")]),t._v(" "),e("h2",{attrs:{id:"什么是并发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是并发"}},[t._v("#")]),t._v(" 什么是并发")]),t._v(" "),e("p",[t._v("并发，在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192",target:"_blank",rel:"noopener noreferrer"}},[t._v("操作系统"),e("OutboundLink")],1),t._v("中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA/128842",target:"_blank",rel:"noopener noreferrer"}},[t._v("处理机"),e("OutboundLink")],1),t._v("上运行，但任一个时刻点上只有一个程序在处理机上运行。")]),t._v(" "),e("h3",{attrs:{id:"并发的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发的特点"}},[t._v("#")]),t._v(" 并发的特点")]),t._v(" "),e("ul",[e("li",[t._v("程序与计算机不在一一对应，一个程序副本可以有多个计算")]),t._v(" "),e("li",[t._v("并发程序之间具有制约关系，直接制约体现在一个程序需要另一个程序的计算结果，间接制约为多个程序竞争某一资源，如处理机，缓存区等")]),t._v(" "),e("li",[t._v("并发程序在执行中是走走停停，继续推进的。")])]),t._v(" "),e("h3",{attrs:{id:"与并行的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与并行的区别"}},[t._v("#")]),t._v(" 与并行的区别")]),t._v(" "),e("p",[e("strong",[t._v("并发")]),t._v("当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。")]),t._v(" "),e("p",[t._v("**并行：**当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。")]),t._v(" "),e("p",[t._v("**区别：**并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("多道程序"),e("OutboundLink")],1),t._v("环境下，"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E6%80%A7",target:"_blank",rel:"noopener noreferrer"}},[t._v("并发性"),e("OutboundLink")],1),t._v("是指在一段时间内宏观上有多个程序在同时运行，但在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%8D%95%E5%A4%84%E7%90%86%E6%9C%BA%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("单处理机系统"),e("OutboundLink")],1),t._v("中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F",target:"_blank",rel:"noopener noreferrer"}},[t._v("计算机系统"),e("OutboundLink")],1),t._v("中有多个"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[t._v("处理机"),e("OutboundLink")],1),t._v("，则这些可以并发执行的程序便可被分配到多个处理机上，实现"),e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C",target:"_blank",rel:"noopener noreferrer"}},[t._v("并行执行"),e("OutboundLink")],1),t._v("，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行")]),t._v(" "),e("h3",{attrs:{id:"并发的主要操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发的主要操作"}},[t._v("#")]),t._v(" 并发的主要操作")]),t._v(" "),e("p",[t._v("核心Java提供对多线程程序的完全控制。 也可以开发一个可以根据您的要求完全暂停，恢复或停止的多线程程序。 有各种静态方法可以用于线程对象来控制它们的行为。 下表列出了这些方法 -")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("编号")]),t._v(" "),e("th",[t._v("方法")]),t._v(" "),e("th",[t._v("说明描述")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("1")]),t._v(" "),e("td",[e("code",[t._v("public void suspend()")])]),t._v(" "),e("td",[t._v("该方法使线程处于挂起状态，可以使用"),e("code",[t._v("resume()")]),t._v("方法恢复。")])]),t._v(" "),e("tr",[e("td",[t._v("2")]),t._v(" "),e("td",[e("code",[t._v("public void stop()")])]),t._v(" "),e("td",[t._v("该方法使线程完全停止。")])]),t._v(" "),e("tr",[e("td",[t._v("3")]),t._v(" "),e("td",[e("code",[t._v("public void resume()")])]),t._v(" "),e("td",[t._v("该方法恢复使用"),e("code",[t._v("suspend()")]),t._v("方法挂起的线程。")])]),t._v(" "),e("tr",[e("td",[t._v("4")]),t._v(" "),e("td",[e("code",[t._v("public void wait()")])]),t._v(" "),e("td",[t._v("导致当前线程等到另一个线程调用"),e("code",[t._v("notify()")]),t._v("。")])]),t._v(" "),e("tr",[e("td",[t._v("5")]),t._v(" "),e("td",[e("code",[t._v("public void notify()")])]),t._v(" "),e("td",[t._v("唤醒在此对象监视器上等待的单个线程。")])])])]),t._v(" "),e("p",[t._v("请注意，最新版本的Java已经不再使用"),e("code",[t._v("suspend()")]),t._v("，"),e("code",[t._v("resume()")]),t._v("和"),e("code",[t._v("stop()")]),t._v("方法，因此您需要使用可用的替代方法。")]),t._v(" "),e("h3",{attrs:{id:"并发编程的3要素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发编程的3要素"}},[t._v("#")]),t._v(" 并发编程的3要素")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("原子性:")]),t._v(" 一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。")]),t._v(" "),e("li",[e("strong",[t._v("有序性:")]),t._v(" 程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）")]),t._v(" "),e("li",[e("strong",[t._v("可见性:")]),t._v(" 一个县城对共享变量的修改,另一个线程能够立刻看到。")])]),t._v(" "),e("h2",{attrs:{id:"线程间通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信"}},[t._v("#")]),t._v(" 线程间通信")]),t._v(" "),e("p",[t._v("线程间通信的模型有两种："),e("strong",[t._v("共享内存")]),t._v("和"),e("strong",[t._v("消息传递")]),t._v("，以下方式都是基本这两种模型来实现的。")]),t._v(" "),e("h2",{attrs:{id:"锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),e("h3",{attrs:{id:"juc-lock接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#juc-lock接口"}},[t._v("#")]),t._v(" JUC Lock接口")]),t._v(" "),e("p",[e("code",[t._v("java.util.concurrent.locks.Lock")]),t._v("接口用作线程同步机制，类似于同步块。新的锁定机制更灵活，提供比同步块更多的选项。 锁和同步块之间的主要区别如下：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("序列的保证")]),t._v(" - 同步块不提供对等待线程进行访问的序列的任何保证，但"),e("code",[t._v("Lock")]),t._v("接口处理它。")]),t._v(" "),e("li",[e("strong",[t._v("无超时")]),t._v("，如果未授予锁，则同步块没有超时选项。"),e("code",[t._v("Lock")]),t._v("接口提供了这样的选项。")]),t._v(" "),e("li",[e("strong",[t._v("单一方法")]),t._v("同步块必须完全包含在单个方法中，而"),e("code",[t._v("Lock")]),t._v("接口的方法"),e("code",[t._v("lock()")]),t._v("和"),e("code",[t._v("unlock()")]),t._v("可以以不同的方式调用。")])]),t._v(" "),e("h3",{attrs:{id:"juc-readwritelock接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#juc-readwritelock接口"}},[t._v("#")]),t._v(" JUC ReadWriteLock接口")]),t._v(" "),e("p",[e("code",[t._v("java.util.concurrent.locks.ReadWriteLock")]),t._v("接口允许一次读取多个线程，但一次只能写入一个线程。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("读锁")]),t._v(" - 如果没有线程锁定"),e("code",[t._v("ReadWriteLock")]),t._v("进行写入，则多线程可以访问读锁。")]),t._v(" "),e("li",[e("strong",[t._v("写锁")]),t._v(" - 如果没有线程正在读或写，那么一个线程可以访问写锁。")])]),t._v(" "),e("h3",{attrs:{id:"juc-condition接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#juc-condition接口"}},[t._v("#")]),t._v(" JUC Condition接口")]),t._v(" "),e("p",[e("code",[t._v("java.util.concurrent.locks.Condition")]),t._v("接口提供一个线程挂起执行的能力，直到给定的条件为真。 "),e("code",[t._v("Condition")]),t._v("对象必须绑定到"),e("code",[t._v("Lock")]),t._v("，并使用"),e("code",[t._v("newCondition()")]),t._v("方法获取对象")]),t._v(" "),e("h2",{attrs:{id:"线程锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程锁"}},[t._v("#")]),t._v(" 线程锁")]),t._v(" "),e("h2",{attrs:{id:"juc-aqs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#juc-aqs"}},[t._v("#")]),t._v(" JUC -AQS")]),t._v(" "),e("p",[t._v("java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心")]),t._v(" "),e("h3",{attrs:{id:"countdownlatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[t._v("#")]),t._v(" CountDownLatch")]),t._v(" "),e("h3",{attrs:{id:"cyclicbarrier"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier"}},[t._v("#")]),t._v(" CyclicBarrier")]),t._v(" "),e("h3",{attrs:{id:"semaphore"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#semaphore"}},[t._v("#")]),t._v(" Semaphore")]),t._v(" "),e("h3",{attrs:{id:"reentrantlock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[t._v("#")]),t._v(" ReentrantLock")])])}),[],!1,null,null,null);r.default=_.exports}}]);