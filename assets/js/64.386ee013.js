(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{458:function(t,s,a){"use strict";a.r(s);var n=a(31),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"国机工业设计研究院"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#国机工业设计研究院"}},[t._v("#")]),t._v(" 国机工业设计研究院")]),t._v(" "),a("h3",{attrs:{id:"业务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#业务"}},[t._v("#")]),t._v(" 业务")]),t._v(" "),a("p",[a("strong",[t._v("BIM轻量化引擎")])]),t._v(" "),a("p",[a("strong",[t._v("BIM轻量化对接")])]),t._v(" "),a("p",[a("strong",[t._v("文件存储，模型的存储")])]),t._v(" "),a("p",[a("strong",[t._v("模型的存储，模型上传流程，大文件处理，轻量模型下载")])]),t._v(" "),a("p",[t._v("SparkMd5")]),t._v(" "),a("p",[a("strong",[t._v("文件在流程中是如何使用的，文件下载权限")])]),t._v(" "),a("p",[a("strong",[t._v("授权解决方案 auth2")])]),t._v(" "),a("p",[a("strong",[t._v("auth2的授权码模式")])]),t._v(" "),a("p",[a("strong",[t._v("spring cloud 组件")])]),t._v(" "),a("p",[a("strong",[t._v("spring cloud alibaba")])]),t._v(" "),a("p",[a("strong",[t._v("微服务与单体应用")])]),t._v(" "),a("p",[a("strong",[t._v("采用微服务的好处")])]),t._v(" "),a("p",[a("strong",[t._v("档案资料服务的设计，levelDeep")])]),t._v(" "),a("p",[a("strong",[t._v("树节点拖动，拖动排序的问题")])]),t._v(" "),a("p",[a("strong",[t._v("线程安全问题")])]),t._v(" "),a("p",[a("strong",[t._v("锁")])]),t._v(" "),a("p",[a("strong",[t._v("synchronized和Lock的却别")])]),t._v(" "),a("p",[a("strong",[t._v("hashMap")])]),t._v(" "),a("p",[a("strong",[t._v("HashMap的性能使用的优化")])]),t._v(" "),a("p",[a("strong",[t._v("JVM")])]),t._v(" "),a("p",[a("strong",[t._v("常量池")])]),t._v(" "),a("p",[a("strong",[t._v("两个方法中使用的String 的字符串一致，他们是同一个对象吗")])]),t._v(" "),a("h3",{attrs:{id:"算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),a("p",[a("strong",[t._v("求链表的中间节点")])]),t._v(" "),a("p",[t._v("int i;")]),t._v(" "),a("p",[t._v("while(head.next!=null){")]),t._v(" "),a("p",[t._v("i++;")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("for(){")]),t._v(" "),a("p",[t._v("if(i==j){")]),t._v(" "),a("p",[t._v("res=head.next")]),t._v(" "),a("p",[t._v("}else{")]),t._v(" "),a("p",[t._v("head.next=head.next")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[a("strong",[t._v("求两个单向链表的交点")])]),t._v(" "),a("p",[t._v("单向链表")]),t._v(" "),a("p",[t._v("link2.next")]),t._v(" "),a("p",[t._v("a->next  a->next")]),t._v(" "),a("p",[t._v("b->next")]),t._v(" "),a("h1",{attrs:{id:"北京小鸟科技股份有限公司-2021-08-13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#北京小鸟科技股份有限公司-2021-08-13"}},[t._v("#")]),t._v(" 北京小鸟科技股份有限公司 2021-08-13")]),t._v(" "),a("p",[a("strong",[t._v("介绍一下档案服务")])]),t._v(" "),a("p",[a("strong",[t._v("介绍一下spring cloud")])]),t._v(" "),a("p",[t._v("把一个大型的单体应用拆分为数十个支持微服务，他可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议")]),t._v(" "),a("p",[t._v("​    "),a("strong",[t._v("定义")]),t._v("：围绕业务领域组件进行创建组件，这些应用可独立进行开发，管理迭代，在分散的组件中使用云架构和平台式部署，管理，和服务功能，使得产品交互更加的简单")]),t._v(" "),a("p",[t._v("​    "),a("strong",[t._v("本质")]),t._v(":  是用一些功能比较明确的，业务精练的服务去解决更大的更实际的问题，（2012年为微服务元年）")]),t._v(" "),a("p",[a("strong",[t._v("服务间调用Feign的理解")])]),t._v(" "),a("p",[t._v("Feign是声明性Web服务客户端。 它使编写Web服务客户端更加容易。 要使用Feign，请创建一个接口并对其进行注释。 它具有可插入注释支持，包括Feign注释和JAX-RS注释。 Feign还支持可插拔编码器和解码器。 Spring Cloud添加了对Spring MVC注释的支持，并支持使用Spring Web中默认使用的相同HttpMessageConverters。 Spring Cloud集成了Eureka和Spring Cloud LoadBalancer，以在使用Feign时提供负载平衡的http客户端。 就是通过把http请求封装到了注解中。")]),t._v(" "),a("p",[t._v("使用OpenFeign的Spring应用架构一般分为三个部分，分别为服务注册中心、服务提供者和服务消费者。服务提供者向服务注册中心注册自己，然后服务消费者通过OpenFeign发送请求时，OpenFeign会向服务注册中心获取关于服务提供者的信息，然后再向服务提供者发送网络请求")]),t._v(" "),a("p",[a("strong",[t._v("为什么标注@FeignClient注解后就能够进行原程调用，底层机制是什么")])]),t._v(" "),a("ul",[a("li",[t._v("启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。")]),t._v(" "),a("li",[t._v("RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。")]),t._v(" "),a("li",[t._v("RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。")]),t._v(" "),a("li",[t._v("最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。")])]),t._v(" "),a("p",[a("strong",[t._v("阅读过哪些源码")])]),t._v(" "),a("p",[a("strong",[t._v("arrayList的源码的中Arrays.copyOf的原理。即System.arraycopy()")])]),t._v(" "),a("p",[t._v("Arrays.copyOf()复制指定的数组，用空值截断或填充（如有必要），使副本具有指定的长度。 对于在原始数组和副本中都有效的所有索引，这两个数组将包含相同的值。 对于副本中有效但不是原始索引的任何索引，副本将包含null 。 当且仅当指定的长度大于原始数组的长度时，此类索引才会存在。 结果数组属于newType类.")]),t._v(" "),a("p",[t._v("实际是调用了System.arraycopy()方法")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("System中提供了一个native静态方法arraycopy(),可以使用这个方法来实现数组之间的复制。对于一维数组来说，这种复制属性值传递，修改副本不会影响原来的值。对于二维或者一维数组中存放的是对象时，复制结果是一维的引用变量传递给副本的一维数组，修改副本时，会影响原来的数组。")])],1),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("arraycopy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" src"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v("  srcPos"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" dest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" destPos"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("从指定的源数组中复制一个数组，从指定位置开始，到目标数组的指定位置。 数组组件的子序列从src引用的源数组复制到dest引用的目标数组。 复制的组件数等于length参数。 源数组中位置srcPos到srcPos+length-1处的组件分别复制到目标数组的位置destPos到destPos+length-1 。\n如果src和dest参数引用同一个数组对象，则执行复制就像将srcPos到srcPos+length-1位置的分量首先复制到具有length分量的临时数组，然后将临时数组的内容复制到通过目标数组的destPos+length-1复制到位置destPos")]),t._v(" "),a("p",[a("strong",[t._v("Synchronized在静态方法中和非静态方法中使用的区别")])]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("Synchronized在静态方法中是加在的类级别的锁称为“类锁”，而在非静态方法中的使用的是加入的方法级别的锁称为‘’对象锁‘’。")])],1),t._v(" "),a("p",[a("strong",[t._v("对于对象锁")]),t._v("：同一个对象在两个线程中分别访问该对象的两个同步方法会产生互斥，因为是对象锁，所以当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。不同对象在两个线程中调用同一个同步方法，不会产生互斥。")]),t._v(" "),a("p",[a("strong",[t._v("对于类锁")]),t._v("：用类直接在两个线程中调用两个不同的同步方法时会产生互斥，因为类对象只有一个。用一个类的静态对象在两个线程中调用静态方法或非静态方法，会产生互斥，因为同时一个对象调用。一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法，不会产生互斥，因为两个方法的锁类型不一致，因此不会互斥，会进行并发执行。")]),t._v(" "),a("p",[a("strong",[t._v("最近学习了哪些知识")])]),t._v(" "),a("p",[a("strong",[t._v("说说项目中的用的设计模式")])]),t._v(" "),a("p",[t._v("工厂模式。")]),t._v(" "),a("p",[t._v("定义一个创建对象的接口，让其子类决定实例化哪一个工厂类。工厂模式的使其创建过程延迟到子类进行。")]),t._v(" "),a("p",[t._v("主要解决问题：解决接口选择的问题。")]),t._v(" "),a("p",[t._v("如何解决：让其子类实现工厂接口，返回一个抽象的产品。")]),t._v(" "),a("p",[a("strong",[t._v("优点：")]),t._v(" 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。")]),t._v(" "),a("p",[t._v("**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。")]),t._v(" "),a("p",[a("strong",[t._v("使用场景：")])]),t._v(" "),a("ol",[a("li",[t._v("日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。")]),t._v(" "),a("li",[t._v("数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。")]),t._v(" "),a("li",[t._v('设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。')])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("创建一个使其继承的接口然后让子类分别去实现这个接口。\n常见工厂类来生成实体类对象：\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShapeFactory")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    \n   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用 getShape 方法获取形状类型的对象")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Shape")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getShape")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" shapeType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("shapeType "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("        \n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("shapeType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equalsIgnoreCase")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"CIRCLE"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Circle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("shapeType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equalsIgnoreCase")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"RECTANGLE"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Rectangle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("shapeType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("equalsIgnoreCase")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SQUARE"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Square")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用时直接从工厂类中获取，")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShapeFactory")]),t._v(" shapeFactory "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ShapeFactory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//获取 Circle 的对象，并调用它的 draw 方法")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Shape")]),t._v(" shape1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" shapeFactory"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getShape")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"CIRCLE"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("说说常见的linux命令，如何查询某个端口是否被占用？")])]),t._v(" "),a("p",[t._v("查看端口是否被占用：lsoft -i:8080     netstat -grep 8080")]),t._v(" "),a("p",[t._v("查找文件：find")]),t._v(" "),a("h1",{attrs:{id:"科瑞思拓有限公司2021-08-14"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#科瑞思拓有限公司2021-08-14"}},[t._v("#")]),t._v(" 科瑞思拓有限公司2021-08-14")]),t._v(" "),a("p",[t._v("个人介绍")]),t._v(" "),a("p",[t._v("介绍最近的项目")]),t._v(" "),a("p",[t._v("简单的聊了聊")]),t._v(" "),a("h1",{attrs:{id:"北京华宇-2021-08-16"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#北京华宇-2021-08-16"}},[t._v("#")]),t._v(" 北京华宇 2021-08-16")]),t._v(" "),a("p",[a("strong",[t._v("项目介绍")])]),t._v(" "),a("p",[a("strong",[t._v("kattle用来干什么")])]),t._v(" "),a("p",[a("strong",[t._v("request和reponse session的区别")])]),t._v(" "),a("p",[t._v("request这个对象不用事先声明，就可以在JSP网页中使用，在编译为Servlet之后，它会转换为javax.servlet.http.HttpServletRequest形态的对象，HttpServletRequest对象是有关于客户端所发出的请求的对象，只要是有关于客户端请求的信息，都可以由它来取得，例如请求标头、请求方法、请求参数、客户端IP，客户端浏览器等等信息。")]),t._v(" "),a("p",[t._v("response是Servlet.service方法的一个参数，类型为javax.servlet.http.HttpServletResponse。在客户端发出每个请求时，服务器都会创建一个response对象，并传入给Servlet.service()方法。response对象是用来对客户端进行响应的，这说明在service()方法中使用response对象可以完成对客户端的响应工作。")]),t._v(" "),a("p",[t._v("session是服务器端技术，数据保存在服务区端,相对来说比较稳定和安全，占用服务器内存,所以一般存活的时间不会太长,超过超时时间就会被销毁.我们要根据服务器的压力和session 的使用情况合理设置session的超时时间,既能保证session的存活时间够用,同时不用的session可以及时销毁减少对服务器内存的占用")]),t._v(" "),a("p",[a("strong",[t._v("session的生命周期,获取session的方式，如何创建session")])]),t._v(" "),a("p",[t._v("session的作用范围是当前的会话范围。")]),t._v(" "),a("p",[t._v("生命周期：")]),t._v(" "),a("p",[t._v("当程序第一次调用到request.getSession()方法时说明客户端明确血药用到session，此时创建出对应的客户端的session对象。")]),t._v(" "),a("p",[t._v("当session超过30分钟时则认为session超时销毁，当程序中明确调用session.invalidate()方法时可以立即杀死session.")]),t._v(" "),a("p",[a("strong",[t._v("jsp和servlet的的区别")])]),t._v(" "),a("p",[t._v("Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层.")]),t._v(" "),a("p",[t._v("JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计。")]),t._v(" "),a("p",[t._v("JSP技术使用Java编程语言编写类XML的tags和scriptlets，来封装产生动态网页的处理逻辑。网页还能通过tags和scriptlets访问存在于服务端的资源的应用逻辑。")]),t._v(" "),a("p",[t._v("JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。 JSP(JavaServer Pages)是一种动态页面技术，它的主要目的是将表示逻辑从Servlet中分离出来")]),t._v(" "),a("p",[a("strong",[t._v("spring mvc干啥用的")])]),t._v(" "),a("p",[t._v("Spring web MVC 提供了模型-视图-控制体系结构来灵活的开发，松散耦合的web的应用的组件 。MVC 模式导致了应用程序的不同方面(输入逻辑、业务逻辑和 UI 逻辑)的分离，同时提供了在这些元素之间的松散耦合。模型封装了应用程序数据，并且通常它们由 POJO 组成。视图主要用于呈现模型数据，并且通常它生成客户端的浏览器可以解释的 HTML 输出。控制器主要用于处理用户请求，并且构建合适的模型并将其传递到视图呈现。")]),t._v(" "),a("p",[a("strong",[t._v("spring mvc 的请求流程")])]),t._v(" "),a("ol",[a("li",[t._v("请求---\x3e前端控制器DispatcherServlet")]),t._v(" "),a("li",[t._v("DispatcherServlet调用HandlerMapping处理器映射器")]),t._v(" "),a("li",[t._v("处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。")]),t._v(" "),a("li",[t._v("DispatcherServlet通过HandlerAdapter处理器适配器调用处理器")]),t._v(" "),a("li",[t._v("执行处理器(Controller，也叫后端控制器)。")]),t._v(" "),a("li",[t._v("Controller执行完成返回ModelAndView")]),t._v(" "),a("li",[t._v("HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet")]),t._v(" "),a("li",[t._v("DispatcherServlet将ModelAndView传给ViewReslover视图解析器")]),t._v(" "),a("li",[t._v("ViewReslover解析后返回具体View")]),t._v(" "),a("li",[t._v("DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。")]),t._v(" "),a("li",[t._v("DispatcherServlet响应用户")])]),t._v(" "),a("p",[a("strong",[t._v("说说常见的设计模式")])]),t._v(" "),a("p",[a("strong",[t._v("装饰者模式和适配器模式的区别")])]),t._v(" "),a("p",[t._v("适配器模式将一个类的接口，转化成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。")]),t._v(" "),a("p",[t._v("装饰者模式：动态的将责任附加到对象上(因为利用组合而不是继承来实现，而组合是可以在运行时进行随机组合的)。若要扩展功能，装饰者提供了比继承更富有弹性的替代方案(同样地，通过组合可以很好的避免类暴涨，也规避了继承中的子类必须无条件继承父类所有属性的弊端")]),t._v(" "),a("p",[t._v("适配器模式主要是为了接口的转换，而装饰者模式关注的是通过组合来动态的为被装饰者注入新的功能或行为(即所谓的责任)。")]),t._v(" "),a("p",[t._v("适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增强新的行为和责任；而外观将一群对象包装起来以简化其接口")]),t._v(" "),a("p",[a("strong",[t._v("auth的认证流程")])]),t._v(" "),a("p",[a("strong",[t._v("redis缓存更新的方式")])]),t._v(" "),a("p",[t._v("最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。")]),t._v(" "),a("ul",[a("li",[t._v("读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。")]),t._v(" "),a("li",[t._v("更新的时候，先更新数据库，然后再删除缓存。")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("为什么是删除缓存，而不是更新缓存？")])])]),t._v(" "),a("p",[t._v("原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。")]),t._v(" "),a("p",[t._v("比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。")]),t._v(" "),a("p",[a("strong",[t._v("1、最初级的缓存不一致问题以及解决方案")])]),t._v(" "),a("p",[a("strong",[t._v("问题：")])]),t._v(" "),a("p",[t._v("​\t先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。")]),t._v(" "),a("p",[a("strong",[t._v("解决思路：")])]),t._v(" "),a("p",[t._v("先删除缓存，再修改数据库，如果删除缓存成功了修改数据库失败了，那么数据库中是旧数据，然后更新到缓存中。")]),t._v(" "),a("p",[a("strong",[t._v("2、并发下数据缓存不一致问题分析")])]),t._v(" "),a("p",[a("strong",[t._v("问题")]),t._v("：")]),t._v(" "),a("p",[t._v("第一个请求数据发生变更，先删除了缓存，然后要去修改数据库，此时还没来得及去修改；")]),t._v(" "),a("p",[t._v("第二个请求过来去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中；")]),t._v(" "),a("p",[t._v("第三个请求读取缓存中的数据 (此时第一个请求已经完成了数据库修改的操作)。")]),t._v(" "),a("p",[t._v("完了，数据库和缓存中的数据不一样了。。。。")]),t._v(" "),a("p",[a("strong",[t._v("问题分析：")])]),t._v(" "),a("p",[t._v("只有在对同一条数据并发读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景;但如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。")]),t._v(" "),a("p",[a("strong",[t._v("解决思路")])]),t._v(" "),a("p",[t._v("数据库的缓存更新与读取操作进行串行化，一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。")]),t._v(" "),a("ol",[a("li",[t._v("首先我们的项目里维护一组线程池和内存队列。")]),t._v(" "),a("li",[t._v("更新数据的时候，根据数据的唯一标识将请求路由到一个jvm队列中，去更新数据库,然后请求结束。")]),t._v(" "),a("li",[t._v("读取数据的时候，先查缓存，如果发现数据不在缓存中，那么将根据唯一标识路由之后，也发送同一个jvm内部的队列中，重新读取数据库后更新缓存,最后请求结束。")])]),t._v(" "),a("p",[a("strong",[t._v("为何用redis中存储用户信息")])]),t._v(" "),a("p",[a("strong",[t._v("HashTable和HashMap的区别")])]),t._v(" "),a("p",[t._v("HashMap和HashTable都是key-value的数据存储格式，HashMap的初始化16，HashTable的初始值为11，HashMap是非线程安全的，HashTable是线程安全的。")]),t._v(" "),a("p",[t._v("HashTable底层其实也是HashMap的原理。")]),t._v(" "),a("p",[t._v("HashMap允许key和value为null,HashTable不允许key和value为null,源码中会抛异常")]),t._v(" "),a("p",[a("strong",[t._v("服务注册与发现机制")])]),t._v(" "),a("p",[a("strong",[t._v("什么是控制反转(IOC)")])]),t._v(" "),a("p",[t._v("IoC 即控制反转，简单来说就是把原来代码⾥需要实现的对象创建、初始化，销毁，依赖反转给容器来帮忙实现，不需要开发者进行控制，实现控制反转。需要创建⼀个容器并且需要⼀种描述让容器知道要创建的对象间的关系，在 Spring 中管理对象及其依赖关系是通过 Spring 的 IoC 容器实现的。")]),t._v(" "),a("p",[t._v("IoC 的实现⽅式有依赖注⼊和依赖查找，由于依赖查找使⽤的很少，因此 IoC 也叫做依赖注⼊。依赖注 ⼊指对象被动地接受依赖类⽽不⽤⾃⼰主动去找，对象不是从容器中查找它依赖的类，⽽是在容器实例 化对象时主动将它依赖的类注⼊给它。假设⼀个 Car 类需要⼀个 Engine 的对象，那么⼀般需要需要⼿ 动 new ⼀个 Engine，利⽤ IoC 就只需要定义⼀个私有的 Engine 类型的成员变量，容器会在运⾏时⾃ 动创建⼀个 Engine 的实例对象并将引⽤⾃动注⼊给成员变量。")]),t._v(" "),a("p",[a("strong",[t._v("一个服务在每天的上午的十点都会挂掉如何处理")])]),t._v(" "),a("p",[a("strong",[t._v("如何进行代码级别的优化")])]),t._v(" "),a("h1",{attrs:{id:"云鸟科技有限公司-2021-08-17"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#云鸟科技有限公司-2021-08-17"}},[t._v("#")]),t._v(" 云鸟科技有限公司 2021-08-17")]),t._v(" "),a("p",[a("strong",[t._v("介绍项目")])]),t._v(" "),a("p",[a("strong",[t._v("什么是多态")])]),t._v(" "),a("p",[t._v("通常使用的方法是重载和重写来实现类多态的性，"),a("font",{attrs:{color:"red"}},[t._v("多态作用：消除类型之间的耦合关系。")])],1),t._v(" "),a("p",[a("strong",[t._v("重载")]),t._v(" ：是方法与方法之间的使用，其中方法的重载是一个类中有多个同名的方法，但是方法中的参数应不相同")]),t._v(" "),a("p",[t._v("// 判断时可以直接根据方法名字来判断；若调用时只需根据参数的类型，很参数的个数即可以调用")]),t._v(" "),a("p",[t._v("构造器就是一个很好的重载的例子：")]),t._v(" "),a("p",[t._v("比如有参构造器，无参构造器。")]),t._v(" "),a("p",[a("strong",[t._v("涉及基本类型的重载：基本类型能从一个”较小“的类型自动提升至一个”较大“的类型，此过程一旦牵扯到重载会造成混淆")])]),t._v(" "),a("p",[a("strong",[t._v("重写")]),t._v("：是子类与父类之间的关系中间涉及到继承与接口的知识")]),t._v(" "),a("p",[a("strong",[t._v("接口和抽象类的区别")])]),t._v(" "),a("p",[t._v("接口与抽象类比较：")]),t._v(" "),a("ul",[a("li",[t._v("接口里只能包含抽象方法，不包含已经提供实现的方法；抽象类则完全可以包含普通方法。")]),t._v(" "),a("li",[t._v("接口里不能定义静态方法；抽象类里可以定义静态方法。")]),t._v(" "),a("li",[t._v("接口里只能定义静态常量Field，不能定义普通Field；抽象类里则既可以定义普通Field，也可以定义静态常量Field。")]),t._v(" "),a("li",[t._v("接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。")]),t._v(" "),a("li",[t._v("接口里不能包含初始化块；但抽象类则完全可以包含初始化块。")]),t._v(" "),a("li",[t._v("一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。")])]),t._v(" "),a("p",[a("strong",[t._v("List和ArrayList的区别,LinkedList,")])]),t._v(" "),a("p",[t._v("List是ArrayList和LinkedList的顶层接口")]),t._v(" "),a("p",[t._v("ArrayList擅长于随机访问，但是在List的中间插入和移除元素时比较慢。")]),t._v(" "),a("p",[t._v("LinkedList 他插入删除操作比较廉价，随机访问方面相对比较慢的。LinkedList还添加了可以使用栈，队列或双端队列的方法。")]),t._v(" "),a("p",[a("strong",[t._v("ArrayList的扩容机制，扩容因子为哪些")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" MAX_ARRAY_SIZE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MAX_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * 增加容量以确保其至少可以容纳最小容量参数指定的元素数\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("grow")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" minCapacity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// overflow-conscious code")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将扩充前的elementData大小给oldCapacity")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" oldCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" elementData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// newCapacity就是1.5倍的oldCapacity")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oldCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" minCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            newCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" minCapacity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" MAX_ARRAY_SIZE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity")]),t._v("\n            newCapacity "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("hugeCapacity")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minCapacity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("////新的容量大小已经确定好了开始copy数组，改变容量")]),t._v("\n        elementData "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Arrays")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("copyOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("elementData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newCapacity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("Spring 事务的传播机制")]),t._v("（就是spring事务的传播行为）")]),t._v(" "),a("p",[t._v("1） PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。")]),t._v(" "),a("p",[t._v("2）PROPAGATION_SUPPORTS ，从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。")]),t._v(" "),a("p",[t._v("3）PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。")]),t._v(" "),a("p",[t._v("4）PROPAGATION_REQUIRES_NEW ，从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。")]),t._v(" "),a("p",[t._v("这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。\n怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。")]),t._v(" "),a("p",[t._v("5）PROPAGATION_NOT_SUPPORTED ，这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。")]),t._v(" "),a("p",[t._v("这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。")]),t._v(" "),a("p",[t._v("6）PROPAGATION_NEVER ，该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。")]),t._v(" "),a("p",[t._v("7）PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。")]),t._v(" "),a("p",[a("strong",[t._v("你说的常见的数据结构和算法")])]),t._v(" "),a("p",[a("strong",[t._v("说一个排序算法")])]),t._v(" "),a("p",[a("strong",[t._v("谈谈HashMap")])]),t._v(" "),a("p",[t._v("HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 "),a("code",[t._v("Map.Entry<K,V>")]),t._v("接口）实现，HashMap 通过 put & get 方法存储和获取。")]),t._v(" "),a("p",[t._v("存储对象时，将 K/V 键值传给 put() 方法：")]),t._v(" "),a("p",[t._v("①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；")]),t._v(" "),a("p",[t._v("②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；")]),t._v(" "),a("p",[t._v("③、 i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；")]),t._v(" "),a("p",[t._v("ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；")]),t._v(" "),a("p",[t._v("iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。")]),t._v(" "),a("blockquote",[a("p",[t._v("（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）\n（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）")])]),t._v(" "),a("p",[t._v("获取对象时，将 K 传给 get() 方法：①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；②、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。")]),t._v(" "),a("p",[t._v("hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等")]),t._v(" "),a("p",[a("strong",[t._v("ConcurrentHashMap的理解")])]),t._v(" "),a("p",[a("strong",[t._v("ConcurrentHashMap")])]),t._v(" "),a("ul",[a("li",[t._v("底层采用分段的数组+链表实现，线程"),a("strong",[t._v("安全")])]),t._v(" "),a("li",[t._v("通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)")]),t._v(" "),a("li",[t._v("Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术")]),t._v(" "),a("li",[t._v("有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁")]),t._v(" "),a("li",[t._v("扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容")])]),t._v(" "),a("p",[a("strong",[t._v("list和set的区别")])]),t._v(" "),a("p",[t._v("list和set都是Collection接口的实现。List接口的实现包括ArrayList和LinkedList。Set接口的实现包括HashSet和TreeSet.")]),t._v(" "),a("p",[t._v("list可以允许重复对象，set不允许重复对象。")]),t._v(" "),a("p",[t._v("list可以插入多个null元素，而set只允许插入一个null元素")]),t._v(" "),a("p",[t._v("list是一个有序的容器，保持每个元素的插入顺序，而set是无序容器，无法保证每个元素的存储顺序，TreeSet通过Comparator或者Comparable维护了一个排序顺序。")]),t._v(" "),a("p",[a("strong",[t._v("如何保证线程安全")])]),t._v(" "),a("p",[t._v("加锁是最简单的直接的方式。synchronized关键字")]),t._v(" "),a("p",[a("strong",[t._v("synchronized为何能保证线程安全")])]),t._v(" "),a("p",[t._v("Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。")]),t._v(" "),a("blockquote",[a("p",[t._v("monitorenter：")])]),t._v(" "),a("p",[t._v("每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：")]),t._v(" "),a("ol",[a("li",[t._v("如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。")]),t._v(" "),a("li",[t._v("如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.")]),t._v(" "),a("li",[t._v("如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。")])]),t._v(" "),a("blockquote",[a("p",[t._v("monitorexit：")])]),t._v(" "),a("p",[t._v("执行monitorexit的线程必须是objectref所对应的monitor的所有者。")]),t._v(" "),a("p",[t._v("指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。")]),t._v(" "),a("p",[a("strong",[t._v("为什么使用索引")])]),t._v(" "),a("p",[a("strong",[t._v("给一个sql语句如何进行优化")])]),t._v(" "),a("p",[a("strong",[t._v("redis的数据存储类型")])]),t._v(" "),a("p",[t._v("String list set zset hash")]),t._v(" "),a("p",[a("strong",[t._v("redis中的跳表的实现")])]),t._v(" "),a("p",[a("strong",[t._v("redis内部的数据存储类型是什么样：")])]),t._v(" "),a("p",[t._v("1.string")]),t._v(" "),a("p",[t._v("string类型对应的是key和value，string类型默认支持三种数据格式：字符串，整数，浮点")]),t._v(" "),a("p",[t._v("在Redis内部，String类型通过 int、SDS(simple dynamic string)作为结构存储，int用来存放整型数据，sds存放字 节/字符串和浮点型数据。Redis是用C语言写的，在C的标准字符串结构下进行了封装，用来提升基本操作的性能，同时也充分利用已有的 C的标准库，简化实现逻辑。")]),t._v(" "),a("p",[t._v("2.list")]),t._v(" "),a("p",[t._v("列表类型内部使用双向链表实现，所以向列表两端添加元素的时间复杂度为O(1), 获取越接近两端的元素速度就越 快。即使是一个有几千万个元素的列表，获取头部或尾部的几条记录也是很快的\n不同版本内部数据结构的差异：\nredis3.2之前，List类型的value对象内部以linkedlist或者ziplist来实现, 当list的元素个数和单个元素的长度比较小 的时候，Redis会采用ziplist（压缩列表）来实现来减少内存占用。否则就会采用linkedlist（双向链表）结构。\nredis3.2之后，采用的一种叫quicklist的数据结构来存储list，列表的底层都由quicklist实现。 这两种存储方式都有优缺点，双向链表在链表两端进行push和pop操作，在插入节点上复杂度比较低，但是内存开 销比较大； ziplist存储在一段连续的内存上，所以存储效率很高，但是插入和删除都需要频繁申请和释放内存；\nquicklist仍然是一个双向链表，只是列表的每个节点都是一个ziplist，其实就是linkedlist和ziplist的结合，quicklist 中每个节点ziplist都能够存储多个数据元素，")]),t._v(" "),a("p",[t._v("3.hash")]),t._v(" "),a("p",[t._v("把整体看作一个对象，每个field-value相当于对象的属性和属性值，这个整体的value是个二维表格的形式，可以存储一些对象信息，是个典型的字典结构，在value里面不能在嵌套其他的数据类型的格式。\nmap提供两种结构来存储，一种是hashtable、另一种是ziplist，数据量小的时候用ziplist. 在redis中，哈 希表分为三层，分别是dictEntry，dictht ，dict ：\ndictEntry\n管理一个key-value，同时保留同一个桶中相邻元素的指针，用来维护哈希桶的内部链；\ndictht\n实现一个hash表会使用一个buckets存放dictEntry的地址，一般情况下通过hash(key)%len得到的值就是buckets的 索引，这个值决定了我们要将此dictEntry节点放入buckets的哪个索引里,这个buckets实际上就是我们说的hash 表。dict.h的dictht结构中table存放的就是buckets的地址\ndict\ndictht实际上就是hash表的核心，但是只有一个dictht还不够，比如rehash、遍历hash等操作，所以redis定义了 一个叫dict的结构以支持字典的各种操作，当dictht需要扩容/缩容时，用来管理dictht的迁移\n使用场景：hash的存储方式类似于关系型数据库，可以存储一些对象形式的信息\n4.集合类型（set）\n集合类型中，每个元素都是不同的，也就是不能有重复数据，同时集合类型中的数据是无序的。一个集合类型键可 以存储至多232-1个 。集合类型和列表类型的最大的区别是有序性和唯一性 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在。由于集合类型在redis内部是使用的值 为空的散列表(hash table)，所以这些操作的时间复杂度都是O(1).\nSet在的底层数据结构以intset或者hashtable来存储。当set中只包含整数型的元素时，采用intset来存储，否则， 采用hashtable存储，但是对于set来说，该hashtable的value值用于为NULL。通过key来存储元素\n使用场景：去重，找标签，差集\n5，有序集合 sorted-set\n有序集合类型，和集合类型的区别就是多了有序的功能\n在集合类型的基础上，有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除 和判断元素是否存在等集合类型支持的操作，还能获得分数最高(或最低)的前N个元素、获得指定分数范围内的元 素等与分数有关的操作。虽然集合中每个元素都是不同的，但是他们的分数却可以相同 。\nzset类型的数据结构就比较复杂一点，内部是以ziplist或者skiplist+hashtable来实现，这里面最核心的一个结构就 是skiplist，也就是跳跃表 。")]),t._v(" "),a("p",[a("strong",[t._v("redis除了set和get数据还在项目中使用过哪些")])]),t._v(" "),a("p",[t._v("当作队列使用")]),t._v(" "),a("p",[a("strong",[t._v("使用的spring cloud的组件有哪些")])]),t._v(" "),a("p",[t._v("Eureka")]),t._v(" "),a("p",[t._v("fegin")]),t._v(" "),a("p",[t._v("Hystrix")]),t._v(" "),a("p",[t._v("getway")]),t._v(" "),a("p",[a("strong",[t._v("泛型有什么作用")])]),t._v(" "),a("p",[a("strong",[t._v("泛型擦除")])]),t._v(" "),a("h1",{attrs:{id:"郑州大方软件-2021-08-17"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#郑州大方软件-2021-08-17"}},[t._v("#")]),t._v(" 郑州大方软件 2021-08-17")]),t._v(" "),a("p",[a("strong",[t._v("个人介绍")])]),t._v(" "),a("p",[a("strong",[t._v("ArrayList和LinkedList的区别")])]),t._v(" "),a("p",[a("strong",[t._v("HashMap的原理")])]),t._v(" "),a("p",[a("strong",[t._v("spring cloud 组件包含哪些")])]),t._v(" "),a("p",[a("strong",[t._v("Feign的实现原理")])]),t._v(" "),a("ul",[a("li",[t._v("启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。")]),t._v(" "),a("li",[t._v("RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。")]),t._v(" "),a("li",[t._v("RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。")]),t._v(" "),a("li",[t._v("最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。")])]),t._v(" "),a("p",[a("strong",[t._v("如何保证线程安全")])]),t._v(" "),a("p",[a("strong",[t._v("rabbitMq中的队列了解吗")])]),t._v(" "),a("p",[a("strong",[t._v("Feign的使用")])]),t._v(" "),a("p",[a("strong",[t._v("系统中遇到的棘手的问题")])]),t._v(" "),a("p",[a("strong",[t._v("ribbon如何做负载均衡的")])]),t._v(" "),a("p",[a("strong",[t._v("spring cloud GetWay是如何找到各个服务的")])]),t._v(" "),a("p",[a("strong",[t._v("分布式配置中心如过配置文件改变是如何通知到各个服务的")])]),t._v(" "),a("p",[a("strong",[t._v("分布式事务的解决方案")])]),t._v(" "),a("p",[a("strong",[t._v("两阶段提交是怎么样的概念")])]),t._v(" "),a("p",[a("strong",[t._v("微服务中如何保证数据一致性")])]),t._v(" "),a("p",[a("strong",[t._v("feign调用超时怎么办")])]),t._v(" "),a("p",[a("strong",[t._v("索引优化")])]),t._v(" "),a("p",[a("strong",[t._v("sql优化有哪些")])]),t._v(" "),a("p",[a("strong",[t._v("自己的优势")])]),t._v(" "),a("h1",{attrs:{id:"河南货行千里-2021-08-18"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#河南货行千里-2021-08-18"}},[t._v("#")]),t._v(" 河南货行千里 2021-08-18")]),t._v(" "),a("p",[a("strong",[t._v("介绍项目")])]),t._v(" "),a("p",[a("strong",[t._v("spring cloud的组件")])]),t._v(" "),a("p",[a("strong",[t._v("服务间调用有哪些")])]),t._v(" "),a("p",[a("strong",[t._v("springboot说说")])]),t._v(" "),a("p",[a("strong",[t._v("@Bean有什么用")])]),t._v(" "),a("p",[a("strong",[t._v("getway如何配置多路径访问")])]),t._v(" "),a("p",[a("strong",[t._v("负载均衡用的什么")])]),t._v(" "),a("p",[a("strong",[t._v("Hystrix的熔断的阈值是多少")])])])}),[],!1,null,null,null);s.default=e.exports}}]);